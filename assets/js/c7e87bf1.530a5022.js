"use strict";(self.webpackChunkblog=self.webpackChunkblog||[]).push([[1450],{3905:(e,t,n)=>{n.d(t,{Zo:()=>l,kt:()=>m});var a=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function d(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var s=a.createContext({}),c=function(e){var t=a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},l=function(e){var t=c(e.components);return a.createElement(s.Provider,{value:t},e.children)},h="mdxType",p={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},u=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,i=e.originalType,s=e.parentName,l=d(e,["components","mdxType","originalType","parentName"]),h=c(n),u=r,m=h["".concat(s,".").concat(u)]||h[u]||p[u]||i;return n?a.createElement(m,o(o({ref:t},l),{},{components:n})):a.createElement(m,o({ref:t},l))}));function m(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var i=n.length,o=new Array(i);o[0]=u;var d={};for(var s in t)hasOwnProperty.call(t,s)&&(d[s]=t[s]);d.originalType=e,d[h]="string"==typeof e?e:r,o[1]=d;for(var c=2;c<i;c++)o[c]=n[c];return a.createElement.apply(null,o)}return a.createElement.apply(null,n)}u.displayName="MDXCreateElement"},5141:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>o,default:()=>h,frontMatter:()=>i,metadata:()=>d,toc:()=>c});var a=n(7462),r=(n(7294),n(3905));const i={},o="Concurrency in C++",d={unversionedId:"concurrency-in-cpp/Concurrency in C++",id:"concurrency-in-cpp/Concurrency in C++",title:"Concurrency in C++",description:"Getting started",source:"@site/docs/concurrency-in-cpp/Concurrency in C++.md",sourceDirName:"concurrency-in-cpp",slug:"/concurrency-in-cpp/Concurrency in C++",permalink:"/docs/concurrency-in-cpp/Concurrency in C++",draft:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/concurrency-in-cpp/Concurrency in C++.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Concurrency in Cpp",permalink:"/docs/category/concurrency-in-cpp"}},s={},c=[{value:"Getting started",id:"getting-started",level:2},{value:"Basic thread management",id:"basic-thread-management",level:2},{value:"Launching a thread",id:"launching-a-thread",level:3},{value:"Waiting for a thread to complete",id:"waiting-for-a-thread-to-complete",level:3},{value:"Waiting in exceptional circumstances",id:"waiting-in-exceptional-circumstances",level:3},{value:"Running threads in the background",id:"running-threads-in-the-background",level:3},{value:"Passing arguments to a thread function",id:"passing-arguments-to-a-thread-function",level:2},{value:"Transferring ownership of a thread",id:"transferring-ownership-of-a-thread",level:2},{value:"Choosing the number of threads at runtime",id:"choosing-the-number-of-threads-at-runtime",level:2},{value:"Identifying threads",id:"identifying-threads",level:2}],l={toc:c};function h(e){let{components:t,...n}=e;return(0,r.kt)("wrapper",(0,a.Z)({},l,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"concurrency-in-c"},"Concurrency in C++"),(0,r.kt)("h2",{id:"getting-started"},"Getting started"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},'#include <iostream>\n#include <thread>\nvoid hello() {\n    std::cout << "Hello Concurrent World\\n";\n}\n\nint main() {\n    std::thread t(hello);\n    t.join();\n}\n')),(0,r.kt)("p",null,"The declarations for the multithreading support in the Standard C++ Library are in new headers: the functions and classes for managing threads are declared in ",(0,r.kt)("inlineCode",{parentName:"p"},"<thread>"),", whereas those for protecting shared data are in other headers."),(0,r.kt)("p",null,"Since every thread has to have an ",(0,r.kt)("inlineCode",{parentName:"p"},"initial function"),", where the new thread of execution begins, the code for writing the message has been moved to a separate function. For the initial thread in an application, this is ",(0,r.kt)("inlineCode",{parentName:"p"},"main()"),", but for every other thread it's specified in the constructor of a ",(0,r.kt)("inlineCode",{parentName:"p"},"std::thread")," object."),(0,r.kt)("p",null,"After the new thread has been launched, the initial thread continues execution. If it didn't wait for the new thread to finish, it would merrily continue to the end of ",(0,r.kt)("inlineCode",{parentName:"p"},"main()")," and end the program. ",(0,r.kt)("inlineCode",{parentName:"p"},"join()")," causes the calling thread to wait for the thread associated whti the ",(0,r.kt)("inlineCode",{parentName:"p"},"std::thread")," object."),(0,r.kt)("h2",{id:"basic-thread-management"},"Basic thread management"),(0,r.kt)("p",null,"The program exits when it returns from ",(0,r.kt)("inlineCode",{parentName:"p"},"main()"),", when the specified entry point function returns, the thread exits."),(0,r.kt)("h3",{id:"launching-a-thread"},"Launching a thread"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"void do_some_word();\nstd::thread my_thread(do_some_work);\n")),(0,r.kt)("p",null,"As with much of the C++ Standard Library, ",(0,r.kt)("inlineCode",{parentName:"p"},"std::thread")," works with any callable type, so you can pass an instance of a class with a function call operator to the ",(0,r.kt)("inlineCode",{parentName:"p"},"std::thread")," constructor instead:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"class background_task {\n    public:\n        void operator() () const {\n            do_something();\n            do_something_else();\n        }\n}\nbackground_task f;\nstd::thread my_thread(f);\n")),(0,r.kt)("p",null,"In this case, the supplied function object is copied into the storage belonging to the newly created thread of execution and invoked from there. "),(0,r.kt)("p",null,"The previous example can be written using a ",(0,r.kt)("inlineCode",{parentName:"p"},"lambda expression")," as follows:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"std::thread my_thread([] {\n   do_something();\n    do_something_else(); \n});\n")),(0,r.kt)("p",null,"If you don't wait for your thread to finish, you need to ensure that the data accessed by the thread is valid until the thread has finished with it. One common way to handle this scenario is to make the thread function self-contained and copy the data into the thread rather than sharing the data."),(0,r.kt)("h3",{id:"waiting-for-a-thread-to-complete"},"Waiting for a thread to complete"),(0,r.kt)("p",null,"If you need to wait for a thread to complete, you can do this by calling ",(0,r.kt)("inlineCode",{parentName:"p"},"join()")," on the associated ",(0,r.kt)("inlineCode",{parentName:"p"},"std::thread")," instance. The act of calling ",(0,r.kt)("inlineCode",{parentName:"p"},"join()")," also cleans up any storage associated with the thread, so the ",(0,r.kt)("inlineCode",{parentName:"p"},"std::thread")," object is no longer associated with the now-finished thread; it isn't associated with any thread."),(0,r.kt)("h3",{id:"waiting-in-exceptional-circumstances"},"Waiting in exceptional circumstances"),(0,r.kt)("p",null,"If you're detaching a thread, you can usually call ",(0,r.kt)("inlineCode",{parentName:"p"},"detach()")," immediately after the thread has been started. But if you're intending to wait for the thread, you need to carefully pick the place in the code where you call ",(0,r.kt)("inlineCode",{parentName:"p"},"join()"),". This means that the call to ",(0,r.kt)("inlineCode",{parentName:"p"},"join()")," is liable to be skipped if an exception is thrown after the thread has been started but before the call to ",(0,r.kt)("inlineCode",{parentName:"p"},"join()"),"."),(0,r.kt)("p",null,"One way of doing this is to use the standard ",(0,r.kt)("inlineCode",{parentName:"p"},"RAII")," and provide a class that does the ",(0,r.kt)("inlineCode",{parentName:"p"},"join()")," in its destructor, as in the following listing:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"class thread_guard {\n    std::thread& t;\n    public:\n        explicit thread_guard(std::thread& t_):\n            t(t_){}\n        ~thread_guard() {\n            if(t.joinable()) t.join();\n        }\n        thread_guard(thread_guard const&) = delete;\n        thread_guard& operator=(thread_guard const&) = delete;\n}\n\nstruct func;\nvoid f() {\n    int some_local_state = 0;\n    func my_func(some_local_state);\n    std::thread t(my_func);\n    thread_guard g(t);\n    do_something_in_current_thread();\n}\n")),(0,r.kt)("p",null,"TThe destructor of ",(0,r.kt)("inlineCode",{parentName:"p"},"thread_guard")," to see if the ",(0,r.kt)("inlineCode",{parentName:"p"},"std::thread")," object is ",(0,r.kt)("inlineCode",{parentName:"p"},"joinable()")," before calling ",(0,r.kt)("inlineCode",{parentName:"p"},"join()")," is important because ",(0,r.kt)("inlineCode",{parentName:"p"},"join()")," can be called only once for a given thread of execution."),(0,r.kt)("p",null,"The copy constructor and copy-assignment operators are marked ",(0,r.kt)("inlineCode",{parentName:"p"},"=delete")," to ensure that they're not automatically provided by the compiler."),(0,r.kt)("p",null,"If you don't needd to wait for a thread to finish, you can avoid this exception-safety issue by ",(0,r.kt)("inlineCode",{parentName:"p"},"detaching")," it."),(0,r.kt)("h3",{id:"running-threads-in-the-background"},"Running threads in the background"),(0,r.kt)("p",null,"Calling ",(0,r.kt)("inlineCode",{parentName:"p"},"detach()")," on a ",(0,r.kt)("inlineCode",{parentName:"p"},"std::thread")," object leaves the thread to run in the background, with no direct means of communicating with it. Ownership and control are passed over to the C++ Runtime Library, which ensures that the resources associated with the thread are correctly reclasimed when the thread exits."),(0,r.kt)("p",null,"Detached threads are often called ",(0,r.kt)("inlineCode",{parentName:"p"},"daemon threads")," after the UNIX concept of a ",(0,r.kt)("inlineCode",{parentName:"p"},"daemon process")," that runs in the background without any explicit user interface. "),(0,r.kt)("p",null,"You can't call ",(0,r.kt)("inlineCode",{parentName:"p"},"detach()")," on a ",(0,r.kt)("inlineCode",{parentName:"p"},"std::thread")," object with no associated thread of execution so you can only call ",(0,r.kt)("inlineCode",{parentName:"p"},"t.detach()")," for a ",(0,r.kt)("inlineCode",{parentName:"p"},"std::thread")," object ",(0,r.kt)("inlineCode",{parentName:"p"},"t")," when ",(0,r.kt)("inlineCode",{parentName:"p"},"t.joinable()")," returns ",(0,r.kt)("inlineCode",{parentName:"p"},"true"),"."),(0,r.kt)("h2",{id:"passing-arguments-to-a-thread-function"},"Passing arguments to a thread function"),(0,r.kt)("p",null,"By default, the arguments are copied into internal storage, where they can be accessed by the newly created thread of execution, and then passed to the callable object or function as rvalues as if they were temporaries. This is done even if the corresponding parameter in the funtion is expecting a reference."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},'void f(int i, std::string const& s);\nstd::thread t(f, 3, "hello");\n')),(0,r.kt)("p",null,'This creates a new thread of execution associated with t, which calls f(3, "hello").'),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},'void f(int i, std::string const& s);\nvoid oops(int some_param) {\n    char buffer[1024];\n    sprintf(buffer, "%i", some_param);\n    std::thread t(f, 3, buffer);\n    t.detach();\n}\n')),(0,r.kt)("p",null,"In this case, it's the pointer to the local variable ",(0,r.kt)("inlineCode",{parentName:"p"},"buffer")," that's passed through to the new thread and there's a significant changce that the ",(0,r.kt)("inlineCode",{parentName:"p"},"oops")," function will exit before the buffer has been converted to a ",(0,r.kt)("inlineCode",{parentName:"p"},"std::string")," on the new thread, thus leading to undefined behavior. The solution is to cast to ",(0,r.kt)("inlineCode",{parentName:"p"},"std::string")," before passing the buffer to the ",(0,r.kt)("inlineCode",{parentName:"p"},"std::thread")," constructor:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"std::thread t(f, 3, std::string(buffer));\n")),(0,r.kt)("p",null,"If the object is copied, and you wanted a ",(0,r.kt)("inlineCode",{parentName:"p"},"non-const")," reference, there will be a compile error."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"void update_data_for_widget(widget_id w, widget_data& data);\nvoid oops_again(widget_id w) {\n    widget_data data;\n    std::thread t(update_data_for_widget, w, data);\n    display_status();\n    t.join();\n    process_widget_data(data);\n}\n")),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"std::thread")," constructor doesn't know that the second parameter is expected to be passed by reference and it blindly copies the supplied values. Therefore, this will fail to compile because the internal code passes copied arguments as rvalues in order to work with move-only types and you can't pass an rvalue to a function that expects a ",(0,r.kt)("inlineCode",{parentName:"p"},"non-const")," reference. In this case, you can fix it by following:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"std::thread t(update_data_for_widget, w, std::ref(data);\n")),(0,r.kt)("h2",{id:"transferring-ownership-of-a-thread"},"Transferring ownership of a thread"),(0,r.kt)("p",null,"Many resource-owning types in the C++ Standard Library, such as ",(0,r.kt)("inlineCode",{parentName:"p"},"std::ifstream")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"std::unique_ptr"),", are movable but not copyable, and ",(0,r.kt)("inlineCode",{parentName:"p"},"std::thread")," is one of them, which means that the ownership of a particular thread of execution can be moved between ",(0,r.kt)("inlineCode",{parentName:"p"},"std::thread")," instances."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"void some_function();\nvoid some_other_function();\nstd::thread t1(some_function);\nstd::thread t2 = std::move(t1);\nt1 = std::thread(some_other_function);\nstd::thread t3;\nt3 = std::move(t2);\nt1 = std::move(t3);\n")),(0,r.kt)("h2",{id:"choosing-the-number-of-threads-at-runtime"},"Choosing the number of threads at runtime"),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"std::thread::hardware_concurrency()")," returns an indication of the number of threads that can truly run concurrently for a given execution of a program. "),(0,r.kt)("h2",{id:"identifying-threads"},"Identifying threads"),(0,r.kt)("p",null,"Thread identifiers are of type ",(0,r.kt)("inlineCode",{parentName:"p"},"std::thread::id")," and can be retrieved in two ways. First, the identifier for a thread can be obtained from its associated ",(0,r.kt)("inlineCode",{parentName:"p"},"std::thread")," object by calling the ",(0,r.kt)("inlineCode",{parentName:"p"},"get_id()")," member function. If the ",(0,r.kt)("inlineCode",{parentName:"p"},"std::thread")," object doesn't have an associated thread of execution, the call to ",(0,r.kt)("inlineCode",{parentName:"p"},"get_id()")," returns a default-constructed ",(0,r.kt)("inlineCode",{parentName:"p"},"std::thread::id")," object, which indicates ",(0,r.kt)("inlineCode",{parentName:"p"},"not any thread"),". Alternatively, the identifier for the current thread can be obtained by calling ",(0,r.kt)("inlineCode",{parentName:"p"},"std::this_thread::get_id()"),". The Standard Library also provides ",(0,r.kt)("inlineCode",{parentName:"p"},"std::hash<std::thread::id>")," so that values of type ",(0,r.kt)("inlineCode",{parentName:"p"},"std::thread::id")," can be used as keys in the new unordered associative containers."),(0,r.kt)("p",null,"Instances of ",(0,r.kt)("inlineCode",{parentName:"p"},"std::thread::id")," are often used to check whether a thread needs to perform some operation."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"std::thread::id master_thread;\nvoid some_core_part_of_algorithm() {\n    if(std::this_thread::get_id() == master_thread) {\n        do_master_thread_work();\n    }\n    do_common_work();\n}\n")))}h.isMDXComponent=!0}}]);