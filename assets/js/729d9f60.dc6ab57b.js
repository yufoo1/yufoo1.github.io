"use strict";(self.webpackChunkblog=self.webpackChunkblog||[]).push([[5190],{3905:(e,a,n)=>{n.d(a,{Zo:()=>c,kt:()=>h});var t=n(7294);function r(e,a,n){return a in e?Object.defineProperty(e,a,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[a]=n,e}function l(e,a){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var t=Object.getOwnPropertySymbols(e);a&&(t=t.filter((function(a){return Object.getOwnPropertyDescriptor(e,a).enumerable}))),n.push.apply(n,t)}return n}function o(e){for(var a=1;a<arguments.length;a++){var n=null!=arguments[a]?arguments[a]:{};a%2?l(Object(n),!0).forEach((function(a){r(e,a,n[a])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):l(Object(n)).forEach((function(a){Object.defineProperty(e,a,Object.getOwnPropertyDescriptor(n,a))}))}return e}function i(e,a){if(null==e)return{};var n,t,r=function(e,a){if(null==e)return{};var n,t,r={},l=Object.keys(e);for(t=0;t<l.length;t++)n=l[t],a.indexOf(n)>=0||(r[n]=e[n]);return r}(e,a);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);for(t=0;t<l.length;t++)n=l[t],a.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var s=t.createContext({}),p=function(e){var a=t.useContext(s),n=a;return e&&(n="function"==typeof e?e(a):o(o({},a),e)),n},c=function(e){var a=p(e.components);return t.createElement(s.Provider,{value:a},e.children)},u="mdxType",m={inlineCode:"code",wrapper:function(e){var a=e.children;return t.createElement(t.Fragment,{},a)}},d=t.forwardRef((function(e,a){var n=e.components,r=e.mdxType,l=e.originalType,s=e.parentName,c=i(e,["components","mdxType","originalType","parentName"]),u=p(n),d=r,h=u["".concat(s,".").concat(d)]||u[d]||m[d]||l;return n?t.createElement(h,o(o({ref:a},c),{},{components:n})):t.createElement(h,o({ref:a},c))}));function h(e,a){var n=arguments,r=a&&a.mdxType;if("string"==typeof e||r){var l=n.length,o=new Array(l);o[0]=d;var i={};for(var s in a)hasOwnProperty.call(a,s)&&(i[s]=a[s]);i.originalType=e,i[u]="string"==typeof e?e:r,o[1]=i;for(var p=2;p<l;p++)o[p]=n[p];return t.createElement.apply(null,o)}return t.createElement.apply(null,n)}d.displayName="MDXCreateElement"},9221:(e,a,n)=>{n.r(a),n.d(a,{assets:()=>s,contentTitle:()=>o,default:()=>u,frontMatter:()=>l,metadata:()=>i,toc:()=>p});var t=n(7462),r=(n(7294),n(3905));const l={sidebar_position:3},o="Catamorphic",i={unversionedId:"haskell/Catamorphic",id:"haskell/Catamorphic",title:"Catamorphic",description:"Functional Programming",source:"@site/docs/haskell/Catamorphic.md",sourceDirName:"haskell",slug:"/haskell/Catamorphic",permalink:"/docs/haskell/Catamorphic",draft:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/haskell/Catamorphic.md",tags:[],version:"current",sidebarPosition:3,frontMatter:{sidebar_position:3},sidebar:"tutorialSidebar",previous:{title:"Recursion and Helper Functions",permalink:"/docs/haskell/Recursion and Helper Functions"},next:{title:"Type System and Defining Custom Types",permalink:"/docs/haskell/Type System and Defining Custom Types"}},s={},p=[{value:"Functional Programming",id:"functional-programming",level:2},{value:"Partial Application",id:"partial-application",level:2},{value:"Prefix and Infix Notations",id:"prefix-and-infix-notations",level:2},{value:"Lambdas",id:"lambdas",level:2},{value:"The . and $ Operation",id:"the--and--operation",level:2},{value:"More Functional List Wrangling Examples",id:"more-functional-list-wrangling-examples",level:2},{value:"Lists and Recursion",id:"lists-and-recursion",level:2},{value:"Constom Operators",id:"constom-operators",level:2},{value:"Typed Holes",id:"typed-holes",level:2}],c={toc:p};function u(e){let{components:a,...n}=e;return(0,r.kt)("wrapper",(0,t.Z)({},c,n,{components:a,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"catamorphic"},"Catamorphic"),(0,r.kt)("h2",{id:"functional-programming"},"Functional Programming"),(0,r.kt)("p",null,"In Haskell, a function is a value. Functions can be passed as parameters to other functions."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"func :: (Int -> Int) -> Int\n")),(0,r.kt)("p",null,"The parentheses are needed because the type ",(0,r.kt)("inlineCode",{parentName:"p"},"Int -> Int -> Int")," would be the type of a function taking two ",(0,r.kt)("inlineCode",{parentName:"p"},"Int")," arguments. Functions that take functions as arguments or return functions are often called ",(0,r.kt)("inlineCode",{parentName:"p"},"higher-order")," functions."),(0,r.kt)("p",null,"The most famous of these list-processing higher-order functions is ",(0,r.kt)("inlineCode",{parentName:"p"},"map"),". It gives you a new list by applying the given function to all elements of a list."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"map :: (a -> b) -> [a] -> [b]\n")),(0,r.kt)("p",null,"The partner in crime for ",(0,r.kt)("inlineCode",{parentName:"p"},"map")," is ",(0,r.kt)("inlineCode",{parentName:"p"},"filter"),". ",(0,r.kt)("inlineCode",{parentName:"p"},"filter")," drops some elements of a list and keeps others."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"filter :: (a -> Bool) -> [a] -> [a]\n")),(0,r.kt)("p",null,"You can also pass constructors as arguments to other functions."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"wrapJust xs = map Just xs\nPrelude> :t wrapJust\nwrapJust :: [a] -> [Maybe a]\nPrelude> wrapJust [1,2,3]\n[Just 1,Just 2,Just 3]\n")),(0,r.kt)("h2",{id:"partial-application"},"Partial Application"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"Prelude> add a b = a+b\nPrelude> addThree = add 3\nPrelude> map addThree [1,2,3]\n[4,5,6]\nPrelude> map (add 3) [1,2,3]\n[4,5,6]\n")),(0,r.kt)("p",null,"We've defined ",(0,r.kt)("inlineCode",{parentName:"p"},"add"),", a function of two arguments, and only given it one argument. The new function just stores the given argument, waits for another argument, and then gives both to ",(0,r.kt)("inlineCode",{parentName:"p"},"add"),"."),(0,r.kt)("p",null,"In addtion to normal functions, partial application alse works with operators."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"Prelude> map (*2) [1,2,3]\n[2,4,6]\nPrelude> map (2*) [1,2,3]\n[2,4,6]\nPrelude> map (1/) [1,2,3,4,5]\n[1.0,0.5,0.3333333333333333,0.25,0.2]\n")),(0,r.kt)("h2",{id:"prefix-and-infix-notations"},"Prefix and Infix Notations"),(0,r.kt)("p",null,"Normal Haskell operators are applied with ",(0,r.kt)("inlineCode",{parentName:"p"},"prefix notation"),", which is just a fancy way to say that the function name comes before the arguments. In contrast, operatos are applied with ",(0,r.kt)("inlineCode",{parentName:"p"},"infix notation"),", which means the name of the function comes between the arguments."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"(+) 1 2 ==> 1 + 2 ==> 3\n")),(0,r.kt)("p",null,"The function ",(0,r.kt)("inlineCode",{parentName:"p"},"zipWith")," takes two lists. It can joins the lists using the function, such as:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"Prelude> zipWith (+) [0,2,5] [1,3,3]\n[1,5,8]\n")),(0,r.kt)("p",null,"Another nice feature of Haskell is the syntax for applying a binary function as if it was an infix operator, by surrounding it with backticks(`):"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"6 `div` 2 ==> div 6 2 ==> 3\n(+1) `map` [1,2,3] ==> map (+1) [1,2,3] ==> [2,3,4]\n")),(0,r.kt)("h2",{id:"lambdas"},"Lambdas"),(0,r.kt)("p",null,"Lambda expression are anonymous functions."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"let big x = x>7 in filter big [1,10,100]\nfilter (\\x -> x>7) [1,10,100]\n")),(0,r.kt)("p",null,"The backslash character(","\\",") stans for the greek letter lambda(",(0,r.kt)("span",{parentName:"p",className:"math math-inline"},(0,r.kt)("span",{parentName:"span",className:"katex"},(0,r.kt)("span",{parentName:"span",className:"katex-mathml"},(0,r.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,r.kt)("semantics",{parentName:"math"},(0,r.kt)("mrow",{parentName:"semantics"},(0,r.kt)("mi",{parentName:"mrow"},"\u03bb")),(0,r.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"\\lambda")))),(0,r.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,r.kt)("span",{parentName:"span",className:"base"},(0,r.kt)("span",{parentName:"span",className:"strut",style:{height:"0.6944em"}}),(0,r.kt)("span",{parentName:"span",className:"mord mathnormal"},"\u03bb"))))),")."),(0,r.kt)("h2",{id:"the--and--operation"},"The . and $ Operation"),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},".")," operator, is the function composition operator:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"(.) :: (b -> c) -> (a -> b) -> a -> c\n")),(0,r.kt)("p",null,"The other operator ",(0,r.kt)("inlineCode",{parentName:"p"},"$")," takes a function of type ",(0,r.kt)("inlineCode",{parentName:"p"},"a -> b")," and a value of type ",(0,r.kt)("inlineCode",{parentName:"p"},"a"),", and returns a value of type ",(0,r.kt)("inlineCode",{parentName:"p"},"b"),". These expressions are the same:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},'head (reverse "abcd")\nhead $ reverse "abcd"\n')),(0,r.kt)("h2",{id:"more-functional-list-wrangling-examples"},"More Functional List Wrangling Examples"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"takeWhile :: (a -> Bool) -> [a] -> [a]   -- take elements from a list as long as they satisfy a predicate\ndropWhile :: (a -> Bool) -> [a] -> [a]   -- drop elements from a list as long as they satisfy a predicate\ntakeWhile even [2,4,1,2,3]   ==> [2,4]\ndropWhile even [2,4,1,2,3]   ==> [1,2,3]\n")),(0,r.kt)("p",null,"There's also the function ",(0,r.kt)("inlineCode",{parentName:"p"},"elem"),", which can be used to check if a list contains an element:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"elem 3 [1,2,3]   ==> True\nelem 4 [1,2,3]   ==> False\n")),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"constant")," function, ",(0,r.kt)("inlineCode",{parentName:"p"},"const :: a -> b -> a")," always returns its first argument:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"const 3 True ==> 3\nconst 3 0    ==> 3\n")),(0,r.kt)("h2",{id:"lists-and-recursion"},"Lists and Recursion"),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},":")," operator builds a list out of a head and a tail. ",(0,r.kt)("inlineCode",{parentName:"p"},"x :: xs")," is the same as ",(0,r.kt)("inlineCode",{parentName:"p"},"[x] ++ xs"),"."),(0,r.kt)("p",null,"It's often convenient to use nested patterns while consuming a list:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"countNothings :: [Maybe a] -> Int\ncountNothings [] = 0\ncountNothings (Nothing : xs) = 1 + countNothings xs\ncountNothings (Just _  : xs) = countNothings xs\n")),(0,r.kt)("p",null,"The direct way of generating a list is simpler, more efficient and more idiomatic."),(0,r.kt)("h2",{id:"constom-operators"},"Constom Operators"),(0,r.kt)("p",null,"In Haskell, an operator is anything built from the characters. Operators can be defined just like functions."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"(<+>) :: [Int] -> [Int] -> [Int]\nxs <+> ys = zipWith (+) xs ys\n")),(0,r.kt)("h2",{id:"typed-holes"},"Typed Holes"),(0,r.kt)("p",null,"A feature called ",(0,r.kt)("inlineCode",{parentName:"p"},"Typed Holes")," lets you leave blanks in your code, and the compiler will tell you what type the expression in the blank should have. Blans can look like ",(0,r.kt)("inlineCode",{parentName:"p"},"_")," or ",(0,r.kt)("inlineCode",{parentName:"p"},"_name"),".A hole occurs on the righ side of a ",(0,r.kt)("inlineCode",{parentName:"p"},"="),", while an anything goes pattern occurs on the left side of a ",(0,r.kt)("inlineCode",{parentName:"p"},"="),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"Prelude> filter _hole [True,False]\n\n<interactive>: error:\n    \u2022 Found hole: _hole :: Bool -> Bool\n    ...\n")))}u.isMDXComponent=!0}}]);