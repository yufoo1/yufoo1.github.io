"use strict";(self.webpackChunkblog=self.webpackChunkblog||[]).push([[9980],{3905:(e,n,t)=>{t.d(n,{Zo:()=>d,kt:()=>h});var a=t(7294);function o(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function i(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function r(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?i(Object(t),!0).forEach((function(n){o(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):i(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function s(e,n){if(null==e)return{};var t,a,o=function(e,n){if(null==e)return{};var t,a,o={},i=Object.keys(e);for(a=0;a<i.length;a++)t=i[a],n.indexOf(t)>=0||(o[t]=e[t]);return o}(e,n);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)t=i[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(o[t]=e[t])}return o}var l=a.createContext({}),p=function(e){var n=a.useContext(l),t=n;return e&&(t="function"==typeof e?e(n):r(r({},n),e)),t},d=function(e){var n=p(e.components);return a.createElement(l.Provider,{value:n},e.children)},m="mdxType",c={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},u=a.forwardRef((function(e,n){var t=e.components,o=e.mdxType,i=e.originalType,l=e.parentName,d=s(e,["components","mdxType","originalType","parentName"]),m=p(t),u=o,h=m["".concat(l,".").concat(u)]||m[u]||c[u]||i;return t?a.createElement(h,r(r({ref:n},d),{},{components:t})):a.createElement(h,r({ref:n},d))}));function h(e,n){var t=arguments,o=n&&n.mdxType;if("string"==typeof e||o){var i=t.length,r=new Array(i);r[0]=u;var s={};for(var l in n)hasOwnProperty.call(n,l)&&(s[l]=n[l]);s.originalType=e,s[m]="string"==typeof e?e:o,r[1]=s;for(var p=2;p<i;p++)r[p]=t[p];return a.createElement.apply(null,r)}return a.createElement.apply(null,t)}u.displayName="MDXCreateElement"},5487:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>r,default:()=>m,frontMatter:()=>i,metadata:()=>s,toc:()=>p});var a=t(7462),o=(t(7294),t(3905));const i={sidebar_position:7},r="Design Patterns for Typed Functional Programming",s={unversionedId:"haskell/Design Patterns for Typed Functional Programming",id:"haskell/Design Patterns for Typed Functional Programming",title:"Design Patterns for Typed Functional Programming",description:"Modeling with Boxes",source:"@site/docs/haskell/Design Patterns for Typed Functional Programming.md",sourceDirName:"haskell",slug:"/haskell/Design Patterns for Typed Functional Programming",permalink:"/docs/haskell/Design Patterns for Typed Functional Programming",draft:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/haskell/Design Patterns for Typed Functional Programming.md",tags:[],version:"current",sidebarPosition:7,frontMatter:{sidebar_position:7},sidebar:"tutorialSidebar",previous:{title:"Classes and Instances",permalink:"/docs/haskell/Classes and Instances"}},l={},p=[{value:"Modeling with Boxes",id:"modeling-with-boxes",level:2},{value:"Modeling with Cases",id:"modeling-with-cases",level:2},{value:"Monoids",id:"monoids",level:2},{value:"Associative Operations",id:"associative-operations",level:3},{value:"Semigroups",id:"semigroups",level:3},{value:"Monoids",id:"monoids-1",level:3},{value:"Why and How to Use Monoids",id:"why-and-how-to-use-monoids",level:3},{value:"Open and Closed Abstractions",id:"open-and-closed-abstractions",level:2},{value:"Modeling with Languages",id:"modeling-with-languages",level:2}],d={toc:p};function m(e){let{components:n,...t}=e;return(0,o.kt)("wrapper",(0,a.Z)({},d,t,{components:n,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"design-patterns-for-typed-functional-programming"},"Design Patterns for Typed Functional Programming"),(0,o.kt)("h2",{id:"modeling-with-boxes"},"Modeling with Boxes"),(0,o.kt)("p",null,"Sometimes, you don't need a new type, but instead can just a standard type. It's common to create a new type that just contains a ",(0,o.kt)("inlineCode",{parentName:"p"},"String"),":"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-haskell"},"data Plate = Plate String\n  deriving (Show, Eq)\n")),(0,o.kt)("p",null,"Addtionally, we can restrict the operations that are possible on ",(0,o.kt)("inlineCode",{parentName:"p"},"Plates")," to a subset of those that are possible on strings. We can also define a constructor for ",(0,o.kt)("inlineCode",{parentName:"p"},"Plate"),":"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-haskell"},"parsePlate :: String -> Maybe Plate\nparsePlate string\n  | correctPlateNumber string  =  Just (Plate string)\n  | otherwise                  =  Nothing\n")),(0,o.kt)("h2",{id:"modeling-with-cases"},"Modeling with Cases"),(0,o.kt)("p",null,"Haskell's algebraic datatypes are really powerful at modeling things based on ",(0,o.kt)("inlineCode",{parentName:"p"},"cases"),". "),(0,o.kt)("p",null,"Many Haskell functions don't work with empty lists. You can track whether lists are possibly empty or guuaranteed to not be empty with ",(0,o.kt)("inlineCode",{parentName:"p"},"NonEmpty")," type from the ",(0,o.kt)("inlineCode",{parentName:"p"},"Data.List.NonEmpty")," module."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-haskell"},"data NonEmpty a = a :| [a]\n")),(0,o.kt)("p",null,"Here the type represents a ",(0,o.kt)("inlineCode",{parentName:"p"},"lack of")," cases. The type ",(0,o.kt)("inlineCode",{parentName:"p"},"NonEmpty a")," will always consist a value of type ",(0,o.kt)("inlineCode",{parentName:"p"},"a"),"."),(0,o.kt)("p",null,"There is also an example of an ",(0,o.kt)("inlineCode",{parentName:"p"},"infix")," constructor. ",(0,o.kt)("inlineCode",{parentName:"p"},"(:)")," is another ",(0,o.kt)("inlineCode",{parentName:"p"},"infix")," constructor that we met earlier. Any operator that begins with a colon(the ",(0,o.kt)("inlineCode",{parentName:"p"},":")," character) can be used as an infix constructor. We can pattern match on ",(0,o.kt)("inlineCode",{parentName:"p"},"(:|)")," just like on ",(0,o.kt)("inlineCode",{parentName:"p"},"(:)"),"."),(0,o.kt)("h2",{id:"monoids"},"Monoids"),(0,o.kt)("p",null,"A pattern that comes up often in functional programming is the ",(0,o.kt)("inlineCode",{parentName:"p"},"monoid"),". Explanations of monoids are very mathematical, but the idea is simple: combining things."),(0,o.kt)("h3",{id:"associative-operations"},"Associative Operations"),(0,o.kt)("p",null,"Many functions and operators we use are ",(0,o.kt)("inlineCode",{parentName:"p"},"associative"),". For example, the ",(0,o.kt)("inlineCode",{parentName:"p"},"++")," operator for catenating lists is associative. Another great example is the function composition operator. Both ",(0,o.kt)("inlineCode",{parentName:"p"},"(head . tail) . tail")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"head . (tail . tail)")," compute the third element of a list."),(0,o.kt)("p",null,"However not all operators are associative. like ",(0,o.kt)("inlineCode",{parentName:"p"},":"),". While ",(0,o.kt)("inlineCode",{parentName:"p"},"True : (False : [])")," is ok, ",(0,o.kt)("inlineCode",{parentName:"p"},"(True : False) : []")," does not even type."),(0,o.kt)("p",null,"In order for an operation to be associative, it needs to take two arguments of the same type."),(0,o.kt)("p",null,"A function ",(0,o.kt)("inlineCode",{parentName:"p"},"f")," is associative if these are the same:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-haskell"},"f x (f y z)\nf (f x y) z\n")),(0,o.kt)("p",null,"Two widely-used associative functions are the ",(0,o.kt)("inlineCode",{parentName:"p"},"min")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"max")," functions."),(0,o.kt)("h3",{id:"semigroups"},"Semigroups"),(0,o.kt)("p",null,"Haskell has a type class ",(0,o.kt)("inlineCode",{parentName:"p"},"Semigroup")," that can be used when a type has one clear associative operation."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-haskell"},"class Semigroup a where\n  -- An associative operation.\n  (<>) :: a -> a -> a\n")),(0,o.kt)("p",null,"Lists are an instance of ",(0,o.kt)("inlineCode",{parentName:"p"},"Semigroup")," with ",(0,o.kt)("inlineCode",{parentName:"p"},"(++)")," as ",(0,o.kt)("inlineCode",{parentName:"p"},"(<>)"),"."),(0,o.kt)("p",null,"Types that have multiple different associative operators usually aren't made an instance of Semigroup. Instead, the Haskell standard library uses boxing. Here are the definitions for ",(0,o.kt)("inlineCode",{parentName:"p"},"Sum")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"Product"),"."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-haskell"},"data Sum a = Sum a\ninstance Num a => Semigroup (Sum a) where\n  Sum a <> Sum b  =  Sum (a+b)\n\ndata Product a = Product a\ninstance Num a => Semigroup (Product a) where\n  Product a <> Product b   =  Product (a*b)\n")),(0,o.kt)("p",null,"There is another benefit of boxing things: being able to declare different type class instances."),(0,o.kt)("h3",{id:"monoids-1"},"Monoids"),(0,o.kt)("p",null,"A ",(0,o.kt)("inlineCode",{parentName:"p"},"monoid")," is a semigroup with a ",(0,o.kt)("inlineCode",{parentName:"p"},"neutral")," element. A neutral element is a zero: an element that does nothing when combined with other elements."),(0,o.kt)("p",null,"The Haskell type class ",(0,o.kt)("inlineCode",{parentName:"p"},"Monoid")," represents monoids."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-haskell"},"class Semigroup a => Monoid a where\n  -- The neutral element\n  mempty :: a\n")),(0,o.kt)("p",null,"Here are the ",(0,o.kt)("inlineCode",{parentName:"p"},"Monoid")," instances corresponding to our three examples of neutral elements:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-haskell"},"instance Monoid (Sum a) where\n  mempty = Sum 0\n\ninstance Monoid (Product a) where\n  mempty = Product 1\n\ninstance Monoid [] where\n  mempty = []\n")),(0,o.kt)("p",null,"A type forms a monoid if there's a way of combining two elements of the type together so that parenthesis don't matter, and there's a alse an ",(0,o.kt)("inlineCode",{parentName:"p"},"empty element")," that can be combined with things without changing them."),(0,o.kt)("h3",{id:"why-and-how-to-use-monoids"},"Why and How to Use Monoids"),(0,o.kt)("p",null,"The reason we want both a neutral element and an associative binary operator is that those are the exact two things we need in order to ",(0,o.kt)("inlineCode",{parentName:"p"},"reduce")," or ",(0,o.kt)("inlineCode",{parentName:"p"},"fold")," multiple elements into on value. This is the job of:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-haskell"},"mconcat :: Monoid a => [a] -> a\n")),(0,o.kt)("p",null,"The actual definitions of ",(0,o.kt)("inlineCode",{parentName:"p"},"Monoid")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"Semigroup")," are:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-haskell"},"class Semigroup a where\n  -- | An associative operation.\n  (<>) :: a -> a -> a\n\n  -- Combine elements of a nonempty list with <>\n  sconcat :: NonEmpty a -> a\n  sconcat as = ... -- default implementation omitted\n\n  -- Combine a value with itself using <>, n times\n  stimes :: Integral b => b -> a -> a\n  stimes n x = ... -- default implementation omitted\n  \nclass Semigroup a => Monoid a where\n  mempty  :: a\n\n  mappend :: a -> a -> a\n  mappend = (<>)\n\n  -- Combine elements of a list with <>\n  mconcat :: [a] -> a\n  mconcat = ... -- default implementation omitted\n")),(0,o.kt)("h2",{id:"open-and-closed-abstractions"},"Open and Closed Abstractions"),(0,o.kt)("p",null,"When we can not only model a type with algebraic datatypes, but also with type classes, the difference is the data-based solution is ",(0,o.kt)("inlineCode",{parentName:"p"},"closed"),", meaning the set of cases if fixed and we can handle all of them in one place, while the class-based solution is open, meaning we can add new cases, even in other modules."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-haskell"},'data Vehicle = Car String | Airplane String\n\nsound :: Vehicle -> String\nsound (Car _) = "brum brum"\nsound (Airplane _) = "zooooom"\n')),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-haskell"},'data Car = Car String\ndata Airplane = Airplane String\n\nclass VehicleClass a where\n  sound :: a -> String\n\ninstance VehicleClass Car where\n  sound (Car _) = "brum brum"\n\ninstance VehicleClass Airplane where\n  sound (Airplane _) = "zooooom"\n')),(0,o.kt)("p",null,"A closed abstraction is nice when we want to know that we've handled all cases,."),(0,o.kt)("h2",{id:"modeling-with-languages"},"Modeling with Languages"),(0,o.kt)("p",null,"Sometimes, it's useful to implement a mini programming language for defcribing parts of your software. The fancy term for these is an ",(0,o.kt)("inlineCode",{parentName:"p"},"Embedded Domain-Specific Language"),". Haskell is well suited to modeling and interpreting languages. The expressions of the language are represented using(often recursive) algebraic data types. The language can be interpreted by a recursive function."))}m.isMDXComponent=!0}}]);