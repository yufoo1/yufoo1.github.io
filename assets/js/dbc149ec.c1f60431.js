"use strict";(self.webpackChunkblog=self.webpackChunkblog||[]).push([[528],{3905:(e,t,n)=>{n.d(t,{Zo:()=>u,kt:()=>m});var a=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function l(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var o=a.createContext({}),p=function(e){var t=a.useContext(o),n=t;return e&&(n="function"==typeof e?e(t):l(l({},t),e)),n},u=function(e){var t=p(e.components);return a.createElement(o.Provider,{value:t},e.children)},c="mdxType",h={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},d=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,i=e.originalType,o=e.parentName,u=s(e,["components","mdxType","originalType","parentName"]),c=p(n),d=r,m=c["".concat(o,".").concat(d)]||c[d]||h[d]||i;return n?a.createElement(m,l(l({ref:t},u),{},{components:n})):a.createElement(m,l({ref:t},u))}));function m(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var i=n.length,l=new Array(i);l[0]=d;var s={};for(var o in t)hasOwnProperty.call(t,o)&&(s[o]=t[o]);s.originalType=e,s[c]="string"==typeof e?e:r,l[1]=s;for(var p=2;p<i;p++)l[p]=n[p];return a.createElement.apply(null,l)}return a.createElement.apply(null,n)}d.displayName="MDXCreateElement"},4294:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>o,contentTitle:()=>l,default:()=>c,frontMatter:()=>i,metadata:()=>s,toc:()=>p});var a=n(7462),r=(n(7294),n(3905));const i={sidebar_position:2},l=void 0,s={unversionedId:"haskell/Recursion and Helper Functions",id:"haskell/Recursion and Helper Functions",title:"Recursion and Helper Functions",description:"Recursion and Helper Functions",source:"@site/docs/haskell/Recursion and Helper Functions.md",sourceDirName:"haskell",slug:"/haskell/Recursion and Helper Functions",permalink:"/docs/haskell/Recursion and Helper Functions",draft:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/haskell/Recursion and Helper Functions.md",tags:[],version:"current",sidebarPosition:2,frontMatter:{sidebar_position:2},sidebar:"tutorialSidebar",previous:{title:"Simple Features of Haskell",permalink:"/docs/haskell/Simple Features of Haskell"},next:{title:"Catamorphic",permalink:"/docs/haskell/Catamorphic"}},o={},p=[{value:"Recursion and Helper Functions",id:"recursion-and-helper-functions",level:2},{value:"Guards",id:"guards",level:2},{value:"Lists",id:"lists",level:2},{value:"List Operations",id:"list-operations",level:3},{value:"Immutability",id:"immutability",level:3},{value:"Type Inference and Polymorphism",id:"type-inference-and-polymorphism",level:3},{value:"The Maybe Type",id:"the-maybe-type",level:3},{value:"Constructors",id:"constructors",level:2},{value:"The Either Type",id:"the-either-type",level:2},{value:"The case-of Expression",id:"the-case-of-expression",level:2}],u={toc:p};function c(e){let{components:t,...n}=e;return(0,r.kt)("wrapper",(0,a.Z)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h2",{id:"recursion-and-helper-functions"},"Recursion and Helper Functions"),(0,r.kt)("p",null,"When you need helper variables in recursion to keep track of things, you can get them by defining a helper function with more arguments. Arguments of the helper function are variables you update in your loop."),(0,r.kt)("p",null,"The type of recursion where a function just directly calls itself with different arguments is called ",(0,r.kt)("inlineCode",{parentName:"p"},"tail recursion"),". Tail recursion corresponds to loops, which means it is often fast because the compiler can generate a loop in machine code when it sees tail recursion."),(0,r.kt)("h2",{id:"guards"},"Guards"),(0,r.kt)("p",null,"An easier alternative when you have multiple cases is Haskell's conditional definition or guarded definition. Guarded definitions loo like this:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"f x y z\n  | condition1 = something\n  | condition2 = other\n  | otherwise  = somethingother\n")),(0,r.kt)("p",null,"A condition can by any expression of type ",(0,r.kt)("inlineCode",{parentName:"p"},"Bool"),"."),(0,r.kt)("h2",{id:"lists"},"Lists"),(0,r.kt)("p",null,"To handle variable numbers of items, we need the ",(0,r.kt)("inlineCode",{parentName:"p"},"list"),", which is also a kine of basic datastucture in Haskell.Lists are used to store multiple values of the same type."),(0,r.kt)("h3",{id:"list-operations"},"List Operations"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"head :: [a] -> a            -- returns the first element\ntail :: [a] -> [a]          -- returns everything except the first element\ninit :: [a] -> [a]          -- returns everything except the last element\ntake :: Int -> [a] -> [a]   -- returns the n first elements\ndrop :: Int -> [a] -> [a]   -- returns everything except the n first elements\n(++) :: [a] -> [a] -> [a]   -- lists are catenated with the ++ operator\n(!!) :: [a] -> Int -> a     -- lists are indexed with the !! operator\nreverse :: [a] -> [a]       -- reverse a list\nnull :: [a] -> Bool         -- is this list empty?\nlength :: [a] -> Int        -- the length of a list\n")),(0,r.kt)("p",null,"Some list operations come from the module ",(0,r.kt)("inlineCode",{parentName:"p"},"Data.List"),". You can import a module in code or in ",(0,r.kt)("inlineCode",{parentName:"p"},"GHCi")," with the ",(0,r.kt)("inlineCode",{parentName:"p"},"import Data.List")," syntax."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"Prelude> import Data.List\nPrelude Data.List> sort [1,0,5,3]\n")),(0,r.kt)("h3",{id:"immutability"},"Immutability"),(0,r.kt)("p",null,"Since Haskell is pure, Haskell list functions always return a new list."),(0,r.kt)("h3",{id:"type-inference-and-polymorphism"},"Type Inference and Polymorphism"),(0,r.kt)("p",null,"Type variables are types that start with a small letter. A type variable means a type that could be anything, which can turn into concreate types by the process of type inference(unification)."),(0,r.kt)("h3",{id:"the-maybe-type"},"The Maybe Type"),(0,r.kt)("p",null,"Sometimes an operation doesn't have a valid value, you can use an error value, like ",(0,r.kt)("inlineCode",{parentName:"p"},"-1")," or In Haskell, change our return type to a ",(0,r.kt)("inlineCode",{parentName:"p"},"Maybe")," type. The type ",(0,r.kt)("inlineCode",{parentName:"p"},"Maybe a")," has two constructors: ",(0,r.kt)("inlineCode",{parentName:"p"},"Nothing")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"Just"),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},'Prelude> :t Nothing\nNothing :: Maybe a\n\nPrelude> :t Just "a camel"\nJust "a camel" :: Maybe [Char]   -- the same as Maybe String\n')),(0,r.kt)("h2",{id:"constructors"},"Constructors"),(0,r.kt)("p",null,"Constructors are special values that start with a capital letter that you can pattern match on. Constructors can be used just like Haskell values. Contructors that take no arguments like ",(0,r.kt)("inlineCode",{parentName:"p"},"Nothing"),", and ",(0,r.kt)("inlineCode",{parentName:"p"},"False")," are just constants. Constructors like ",(0,r.kt)("inlineCode",{parentName:"p"},"Just")," that take an argument behave like functions."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"Prelude> :t Just\nJust :: a -> Maybe a\n")),(0,r.kt)("h2",{id:"the-either-type"},"The Either Type"),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"Either")," type takes two type arguments. The type ",(0,r.kt)("inlineCode",{parentName:"p"},"Either a b")," has two constructors: ",(0,r.kt)("inlineCode",{parentName:"p"},"Left")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"Right"),". Left takes an argument of type a and Right takes an argument of type b. "),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},'readInt :: String -> Either String Int\nreadInt "0" = Right 0\nreadInt "1" = Right 1\nreadInt s = Left ("Unsupported string: " ++ s)\n')),(0,r.kt)("p",null,"Haskell lists can only contain elements of the same type but you can use a type like ",(0,r.kt)("inlineCode",{parentName:"p"},"Either")," to represent lists that can contain two different types of values."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},'lectureParticipants :: [Either String Int]\nlectureParticipants = [Right 10, Right 13, Left "easter vacation", Right 17, Left "lecturer was sick", Right 3]\n')),(0,r.kt)("h2",{id:"the-case-of-expression"},"The case-of Expression"),(0,r.kt)("p",null,"There's a way to pattern match in an expression, which looks like:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},'case <value> of <pattern> -> <expression>\n                <pattern> -> <expression>\n                \ndescribe :: Integer -> String\ndescribe n = case n of 0 -> "zero"\n                       1 -> "one"\n                       2 -> "an even prime"\n                       n -> "the number " ++ show n                \n')))}c.isMDXComponent=!0}}]);