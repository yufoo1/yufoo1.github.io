"use strict";(self.webpackChunkblog=self.webpackChunkblog||[]).push([[4441],{3905:(e,a,t)=>{t.d(a,{Zo:()=>d,kt:()=>c});var n=t(7294);function r(e,a,t){return a in e?Object.defineProperty(e,a,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[a]=t,e}function l(e,a){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);a&&(n=n.filter((function(a){return Object.getOwnPropertyDescriptor(e,a).enumerable}))),t.push.apply(t,n)}return t}function o(e){for(var a=1;a<arguments.length;a++){var t=null!=arguments[a]?arguments[a]:{};a%2?l(Object(t),!0).forEach((function(a){r(e,a,t[a])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):l(Object(t)).forEach((function(a){Object.defineProperty(e,a,Object.getOwnPropertyDescriptor(t,a))}))}return e}function i(e,a){if(null==e)return{};var t,n,r=function(e,a){if(null==e)return{};var t,n,r={},l=Object.keys(e);for(n=0;n<l.length;n++)t=l[n],a.indexOf(t)>=0||(r[t]=e[t]);return r}(e,a);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);for(n=0;n<l.length;n++)t=l[n],a.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(r[t]=e[t])}return r}var s=n.createContext({}),p=function(e){var a=n.useContext(s),t=a;return e&&(t="function"==typeof e?e(a):o(o({},a),e)),t},d=function(e){var a=p(e.components);return n.createElement(s.Provider,{value:a},e.children)},u="mdxType",m={inlineCode:"code",wrapper:function(e){var a=e.children;return n.createElement(n.Fragment,{},a)}},k=n.forwardRef((function(e,a){var t=e.components,r=e.mdxType,l=e.originalType,s=e.parentName,d=i(e,["components","mdxType","originalType","parentName"]),u=p(t),k=r,c=u["".concat(s,".").concat(k)]||u[k]||m[k]||l;return t?n.createElement(c,o(o({ref:a},d),{},{components:t})):n.createElement(c,o({ref:a},d))}));function c(e,a){var t=arguments,r=a&&a.mdxType;if("string"==typeof e||r){var l=t.length,o=new Array(l);o[0]=k;var i={};for(var s in a)hasOwnProperty.call(a,s)&&(i[s]=a[s]);i.originalType=e,i[u]="string"==typeof e?e:r,o[1]=i;for(var p=2;p<l;p++)o[p]=t[p];return n.createElement.apply(null,o)}return n.createElement.apply(null,t)}k.displayName="MDXCreateElement"},6225:(e,a,t)=>{t.r(a),t.d(a,{assets:()=>s,contentTitle:()=>o,default:()=>u,frontMatter:()=>l,metadata:()=>i,toc:()=>p});var n=t(7462),r=(t(7294),t(3905));const l={sidebar_position:4},o="Real Classy",i={unversionedId:"haskell/Real Classy",id:"haskell/Real Classy",title:"Real Classy",description:"Tuples",source:"@site/docs/haskell/Real Classy.md",sourceDirName:"haskell",slug:"/haskell/Real Classy",permalink:"/docs/haskell/Real Classy",draft:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/haskell/Real Classy.md",tags:[],version:"current",sidebarPosition:4,frontMatter:{sidebar_position:4},sidebar:"tutorialSidebar",previous:{title:"Catamorphic",permalink:"/docs/haskell/Catamorphic"},next:{title:"Type System and Defining Custom Types",permalink:"/docs/haskell/Type System and Defining Custom Types"}},s={},p=[{value:"Tuples",id:"tuples",level:2},{value:"Folding",id:"folding",level:2},{value:"Type Constraints",id:"type-constraints",level:2},{value:"Eq",id:"eq",level:3},{value:"Ord",id:"ord",level:3},{value:"Num, Integral Fractional, Floating",id:"num-integral-fractional-floating",level:3},{value:"Read and Show",id:"read-and-show",level:3},{value:"Foldable",id:"foldable",level:3},{value:"More Data Structures",id:"more-data-structures",level:2},{value:"Data.Map",id:"datamap",level:3},{value:"Data.Array",id:"dataarray",level:3},{value:"Reading Docs",id:"reading-docs",level:2}],d={toc:p};function u(e){let{components:a,...t}=e;return(0,r.kt)("wrapper",(0,n.Z)({},d,t,{components:a,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"real-classy"},"Real Classy"),(0,r.kt)("h2",{id:"tuples"},"Tuples"),(0,r.kt)("p",null,"Tuples or pairs are a way of bundling a couple of values of different types together. To get values out of tuples, you can use the functions ",(0,r.kt)("inlineCode",{parentName:"p"},"fst")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"snd"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"fst :: (a, b) -> a\nsnd :: (a, b) -> b\n")),(0,r.kt)("p",null,"you can also pattern match on tuples, which works for tuples of larger sizes."),(0,r.kt)("p",null,"Tuples are very useful in combination with lists. Here are some examples using the ",(0,r.kt)("inlineCode",{parentName:"p"},"zip"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"unzip")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"partition")," functions from the ",(0,r.kt)("inlineCode",{parentName:"p"},"Data.List")," module."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"zip :: [a] -> [b] -> [(a, b)]    -- two lists to list of pairs\nunzip :: [(a, b)] -> ([a], [b])  -- list of pairs to pair of lists\npartition :: (a -> Bool) -> [a] -> ([a], [a])    -- elements that satisfy and don't satisfy a predicate\n")),(0,r.kt)("h2",{id:"folding"},"Folding"),(0,r.kt)("p",null,"Prelude has a function called ",(0,r.kt)("inlineCode",{parentName:"p"},"foldr"),", which performs a right associative fold over a ",(0,r.kt)("inlineCode",{parentName:"p"},"Foldable")," data type."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"foldr :: (a -> b -> b) -> b -> [a] -> b\nfoldr f y []     = y\nfoldr f y (x:xs) = f x (foldr f y xs)\n")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"foldr")," calls its argument function ",(0,r.kt)("inlineCode",{parentName:"p"},"f")," repeatedly with arguments:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"The first argument is the current element from the list."),(0,r.kt)("li",{parentName:"ul"},"The second argument is what ",(0,r.kt)("inlineCode",{parentName:"li"},"f")," returns for the rest of the list.")),(0,r.kt)("h2",{id:"type-constraints"},"Type Constraints"),(0,r.kt)("h3",{id:"eq"},"Eq"),(0,r.kt)("p",null,"In a ",(0,r.kt)("inlineCode",{parentName:"p"},"polymorphic")," function, you need to add ",(0,r.kt)("inlineCode",{parentName:"p"},"type constraints"),". To signal that a function only works on types that are members of the ",(0,r.kt)("inlineCode",{parentName:"p"},"Eq")," class, such as:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"f :: (Eq a) => (a -> a) -> a -> Bool\nf g x = x == g x\n")),(0,r.kt)("p",null,"If you don't have a type annotation, ",(0,r.kt)("inlineCode",{parentName:"p"},"type inference")," can provide the constraints."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"Prelude> f g x = x == g x\nPrelude> :type f\nf :: (Eq a) => (a -> a) -> a -> Bool\n")),(0,r.kt)("h3",{id:"ord"},"Ord"),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"Ord")," class is for ordering. It has values ",(0,r.kt)("inlineCode",{parentName:"p"},"LT")," for ",(0,r.kt)("inlineCode",{parentName:"p"},"less than"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"EQ")," for ",(0,r.kt)("inlineCode",{parentName:"p"},"equal")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"GT")," for ",(0,r.kt)("inlineCode",{parentName:"p"},"greater than"),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"compare :: Ord a => a -> a -> Ordering\n(<) :: Ord a => a -> a -> Bool\n(>) :: Ord a => a -> a -> Bool\n(>=) :: Ord a => a -> a -> Bool\n(<=) :: Ord a => a -> a -> Bool\nmax :: Ord a => a -> a -> a\nmin :: Ord a => a -> a -> a\n")),(0,r.kt)("p",null,"The function ",(0,r.kt)("inlineCode",{parentName:"p"},"sort")," from ",(0,r.kt)("inlineCode",{parentName:"p"},"Data.List")," works on all types that belong to the ",(0,r.kt)("inlineCode",{parentName:"p"},"Ord")," class."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},'-- from the module Data.Ord\n-- compares two values "through" the function f\ncomparing :: (Ord a) => (b -> a) -> b -> b -> Ordering\ncomparing f x y = compare (f x) (f y)\n\n-- from the module Data.List\n-- sorts a list using the given comparison function\nsortBy :: (a -> a -> Ordering) -> [a] -> [a]\n\n-- sorts lists by their length\nsortByLength :: [[a]] -> [[a]]\nsortByLength = sortBy (comparing length)\n')),(0,r.kt)("h3",{id:"num-integral-fractional-floating"},"Num, Integral Fractional, Floating"),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"Num")," class contains integer arithmetic:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"(+) :: Num a => a -> a -> a\n(-) :: Num a => a -> a -> a\n(*) :: Num a => a -> a -> a\nnegate :: Num a => a -> a    -- 0-x\nabs :: Num a => a -> a       -- absolute value\nsignum :: Num a => a -> a    -- -1 for negative values, 0 for 0, +1 for positive values\nfromInteger :: Num a => Integer -> a\n")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"Integral")," is the class of types that represent whole numbers. All types that belong to ",(0,r.kt)("inlineCode",{parentName:"p"},"Integral")," also belong to ",(0,r.kt)("inlineCode",{parentName:"p"},"Num"),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"div :: Integral a => a -> a -> a\nmod :: Integral a => a -> a -> a\n")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"Fractional")," is the class for types that have division. All types that belong ",(0,r.kt)("inlineCode",{parentName:"p"},"Fractional")," alse belong to ",(0,r.kt)("inlineCode",{parentName:"p"},"Num"),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"(/) :: Fractional a => a -> a -> a\n")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"Floating")," contains some additional operations that only make sense for floating point numbers. All types that belong th ",(0,r.kt)("inlineCode",{parentName:"p"},"Floating")," also belong to ",(0,r.kt)("inlineCode",{parentName:"p"},"Fractional"),", of course to ",(0,r.kt)("inlineCode",{parentName:"p"},"Num"),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"sqrt :: Floating a => a -> a\nsin :: Floating a => a -> a\n")),(0,r.kt)("h3",{id:"read-and-show"},"Read and Show"),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"Show")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"Read")," classes are for the functions ",(0,r.kt)("inlineCode",{parentName:"p"},"show")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"read"),", that convert values to and from Strings."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},'show :: Show a => a -> String\nread :: Read a => String -> a\n\nPrelude> show 3\n"3"\nPrelude> read "3" :: Int\n3\nPrelude> read "3" :: Double\n3.0\n')),(0,r.kt)("h3",{id:"foldable"},"Foldable"),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"Foldable")," represents is types that you can fold over. Lists are ",(0,r.kt)("inlineCode",{parentName:"p"},"Foldable")," since we can use ",(0,r.kt)("inlineCode",{parentName:"p"},"length")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"foldr")," on lists. ",(0,r.kt)("inlineCode",{parentName:"p"},"Maybe")," is also ",(0,r.kt)("inlineCode",{parentName:"p"},"Foldable"),". The ",(0,r.kt)("inlineCode",{parentName:"p"},"Foldable")," instance for ",(0,r.kt)("inlineCode",{parentName:"p"},"Maybe")," just pretends that values of ",(0,r.kt)("inlineCode",{parentName:"p"},"Maybe a")," are like lists of length 0 or 1."),(0,r.kt)("h2",{id:"more-data-structures"},"More Data Structures"),(0,r.kt)("h3",{id:"datamap"},"Data.Map"),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"Data.Map")," module defines the ",(0,r.kt)("inlineCode",{parentName:"p"},"Map")," type. Maps are search trees for key-value pairs. Since ",(0,r.kt)("inlineCode",{parentName:"p"},"Data.Map")," contains some function with the same names as ",(0,r.kt)("inlineCode",{parentName:"p"},"Prelude")," functions, the namespace needs to be imported ",(0,r.kt)("inlineCode",{parentName:"p"},"qualified"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"import qualified Data.Map as Map\n")),(0,r.kt)("p",null,"Now we can refer to the map type as `",(0,r.kt)("inlineCode",{parentName:"p"},"Map.Map"),". Here are the most important functions for maps:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"-- Create a Map from a list of key-value pairs\nMap.fromList :: Ord k => [(k, a)] -> Map.Map k a\n\n-- Insert a value into a map. Overrides any previous value with the same key.\n-- Returns a new map. Does not mutate the given map.\nMap.insert :: Ord k => k -> a -> Map.Map k a -> Map.Map k a\n\n-- Get a value from a map using a key. Returns Nothing if the key was not present in the map.\nMap.lookup :: Ord k => k -> Map.Map k a -> Maybe a\n\n-- An empty map\nMap.empty :: Map.Map k a\n")),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"Ord")," constraint for the key type of the map is needed because maps are implemented as ",(0,r.kt)("inlineCode",{parentName:"p"},"ordered binary search trees"),"."),(0,r.kt)("h3",{id:"dataarray"},"Data.Array"),(0,r.kt)("p",null,"Another type that works kind of like a list but is more efficient for some operations is the ",(0,r.kt)("inlineCode",{parentName:"p"},"Array"),"."),(0,r.kt)("p",null,"Unlike the ",(0,r.kt)("inlineCode",{parentName:"p"},"Data.Map")," module, the ",(0,r.kt)("inlineCode",{parentName:"p"},"Data.Array")," can just be imported normally:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"import Data.Array\n")),(0,r.kt)("p",null,"Let's look at the type of the ",(0,r.kt)("inlineCode",{parentName:"p"},"Array")," function that constructs an array."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"array :: Ix i => (i, i) -> [(i, e)] -> Array i e\n")),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"array")," type is parameterized by two types: the index and the element type, which is different from other programming languages. The index type of those languages is always ",(0,r.kt)("inlineCode",{parentName:"p"},"int"),". In Haskell, we can even have ",(0,r.kt)("inlineCode",{parentName:"p"},"Array (Int, Int) Int"),", a two-dimensional array of ints."),(0,r.kt)("p",null,"Not all types can be index types. The ",(0,r.kt)("inlineCode",{parentName:"p"},"Ix")," class collects all the types that can be used as array indices."),(0,r.kt)("p",null,"Then, the ",(0,r.kt)("inlineCode",{parentName:"p"},"array")," function takes an extra ",(0,r.kt)("inlineCode",{parentName:"p"},"(i, i)")," parameter, which are the minimum and maximum indices of the array. Therefore you can define an array that starts from m and goes to n in Haskell."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},'myArray :: Array Int String\nmyArray = array (7,11) [(7,"seven"), (8,"eight"), (9,"nine"), (10,"ten"), (11,"ELEVEN")]\n')),(0,r.kt)("p",null,"There's also the ",(0,r.kt)("inlineCode",{parentName:"p"},"listArray")," constructor that just takes a list of elements in order:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"listArray :: Ix i => (i, i) -> [e] -> Array i e\n")),(0,r.kt)("p",null,"Array are used with two new operators:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"-- Array lookup\n(!) :: Ix i => Array i e -> i -> e\n-- Array update\n(//) :: Ix i => Array i e -> [(i, e)] -> Array i e\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},'Prelude> import Data.Array\nPrelude Data.Array> myArray = listArray (7,11) ["seven", "eight", "nine", "ten", "ELEVEN"]\nPrelude Data.Array> myArray\narray (7,11) [(7,"seven"),(8,"eight"),(9,"nine"),(10,"ten"),(11,"ELEVEN")]\nPrelude Data.Array> myArray ! 8\n"eight"\nPrelude Data.Array> myArray // [(8,"ocho"),(9,"nueve")]\narray (7,11) [(7,"seven"),(8,"ocho"),(9,"nueve"),(10,"ten"),(11,"ELEVEN")]\n')),(0,r.kt)("p",null,"There are many other array types like the mutable ",(0,r.kt)("inlineCode",{parentName:"p"},"IOArray")," and the somewhat obscure ",(0,r.kt)("inlineCode",{parentName:"p"},"DiffArray"),". What'more, there are also type classes for arrays like ",(0,r.kt)("inlineCode",{parentName:"p"},"IArray")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"MArray"),"."),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},"The ",(0,r.kt)("inlineCode",{parentName:"p"},"Map")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"Array")," type are instances of ",(0,r.kt)("inlineCode",{parentName:"p"},"Foldable"),". ")),(0,r.kt)("h2",{id:"reading-docs"},"Reading Docs"),(0,r.kt)("p",null,"Since you are using the ",(0,r.kt)("inlineCode",{parentName:"p"},"stack")," tool, you can also browse the documentation for the libraries stack has installed for you with the commands:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash"},"stack haddock --open\nstack haddock --open <package>\n")))}u.isMDXComponent=!0}}]);