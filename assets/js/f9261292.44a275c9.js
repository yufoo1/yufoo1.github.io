"use strict";(self.webpackChunkblog=self.webpackChunkblog||[]).push([[625],{3905:(e,t,n)=>{n.d(t,{Zo:()=>d,kt:()=>y});var a=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function l(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var i=a.createContext({}),p=function(e){var t=a.useContext(i),n=t;return e&&(n="function"==typeof e?e(t):l(l({},t),e)),n},d=function(e){var t=p(e.components);return a.createElement(i.Provider,{value:t},e.children)},u="mdxType",c={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},m=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,o=e.originalType,i=e.parentName,d=s(e,["components","mdxType","originalType","parentName"]),u=p(n),m=r,y=u["".concat(i,".").concat(m)]||u[m]||c[m]||o;return n?a.createElement(y,l(l({ref:t},d),{},{components:n})):a.createElement(y,l({ref:t},d))}));function y(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var o=n.length,l=new Array(o);l[0]=m;var s={};for(var i in t)hasOwnProperty.call(t,i)&&(s[i]=t[i]);s.originalType=e,s[u]="string"==typeof e?e:r,l[1]=s;for(var p=2;p<o;p++)l[p]=n[p];return a.createElement.apply(null,l)}return a.createElement.apply(null,n)}m.displayName="MDXCreateElement"},5369:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>i,contentTitle:()=>l,default:()=>u,frontMatter:()=>o,metadata:()=>s,toc:()=>p});var a=n(7462),r=(n(7294),n(3905));const o={sidebar_position:3},l="Type System and Defining Custom Types",s={unversionedId:"haskell/Type System and Defining Custom Types",id:"haskell/Type System and Defining Custom Types",title:"Type System and Defining Custom Types",description:"Algebraic Datatypes",source:"@site/docs/haskell/Type System and Defining Custom Types.md",sourceDirName:"haskell",slug:"/haskell/Type System and Defining Custom Types",permalink:"/docs/haskell/Type System and Defining Custom Types",draft:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/haskell/Type System and Defining Custom Types.md",tags:[],version:"current",sidebarPosition:3,frontMatter:{sidebar_position:3},sidebar:"tutorialSidebar",previous:{title:"Catamorphic",permalink:"/docs/haskell/Catamorphic"},next:{title:"Real Classy",permalink:"/docs/haskell/Real Classy"}},i={},p=[{value:"Algebraic Datatypes",id:"algebraic-datatypes",level:2},{value:"Fields",id:"fields",level:3},{value:"Constructors",id:"constructors",level:3},{value:"Deriving",id:"deriving",level:3},{value:"Type Parameters",id:"type-parameters",level:2},{value:"Defining Parameterized Types",id:"defining-parameterized-types",level:3},{value:"Syntactic Note",id:"syntactic-note",level:3},{value:"Multiple Type Parameters",id:"multiple-type-parameters",level:3},{value:"Recursive Types",id:"recursive-types",level:2},{value:"Record Syntax",id:"record-syntax",level:2},{value:"Other Ways of Defining Types",id:"other-ways-of-defining-types",level:2}],d={toc:p};function u(e){let{components:t,...n}=e;return(0,r.kt)("wrapper",(0,a.Z)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"type-system-and-defining-custom-types"},"Type System and Defining Custom Types"),(0,r.kt)("h2",{id:"algebraic-datatypes"},"Algebraic Datatypes"),(0,r.kt)("p",null,"Haskell has a system called ",(0,r.kt)("inlineCode",{parentName:"p"},"algebraic datatypes")," for defining new types. "),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"data Bool = True | False\ndata Ordering = LT | EQ | GT\n")),(0,r.kt)("p",null,"You can also define types with this syntax:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"data Color = Red | Green | Blue\n\n-- a function that uses pattern matching on our new type\nrgb :: Color -> [Double]\nrgb Red = [1,0,0]\nrgb Green = [0,1,0]\nrgb Blue = [0,0,1]\n")),(0,r.kt)("p",null,"Types like that just list a bunch of constants, which are called ",(0,r.kt)("inlineCode",{parentName:"p"},"enumerations")," or ",(0,r.kt)("inlineCode",{parentName:"p"},"enums")," in Haskell. "),(0,r.kt)("p",null,"Each datatype can be a sum of constructors, and each constructor is a product of fields. We can count the possible values of each type this way:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"data Bool = True | False            -- corresponds to 1+1. Has 2 possible values.\ndata TwoBools = TwoBools Bool Bool  -- corresponds to Bool*Bool, i.e. 2*2. Has 4 possible values.\ndata Complex = Two Bool Bool | One Bool | None\n                                    -- corresponds to Bool*Bool+Bool+1 = 2*2+2+1 = 7. Has 7 possible values.\n")),(0,r.kt)("h3",{id:"fields"},"Fields"),(0,r.kt)("p",null,"You need other types as well. For example, to define a type for reports containing an id number, a title, and a body, you can use:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"data Report = ConstructReport Int String String\n")),(0,r.kt)("p",null,"To create it, you should use:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},'Prelude> :t ConstructReport 1 "Title" "This is the body."\nConstructReport 1 "Title" "This is the body." :: Report\n')),(0,r.kt)("p",null,"You can also access the fields with pattern matching:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"reportContents :: Report -> String\nreportContents (ConstructReport id title contents) = contents\nsetReportContents :: String -> Report -> Report\nsetReportContents contents (ConstructReport id title _contents) = ConstructReport id title contents\n")),(0,r.kt)("h3",{id:"constructors"},"Constructors"),(0,r.kt)("p",null,"The things on the right hand side of a ",(0,r.kt)("inlineCode",{parentName:"p"},"data")," declaration are called constructors. A type can have multiple constructors and a constructor can have zero or more fields."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"data Card = Joker | Heart Int | Club Int | Spade Int | Diamond Int\n")),(0,r.kt)("h3",{id:"deriving"},"Deriving"),(0,r.kt)("p",null,"To Tell Haskell how to print the types you defined, you should add a ",(0,r.kt)("inlineCode",{parentName:"p"},"deriving Show")," after the type definition:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"data Card = Joker | Heart Int | Club Int | Spade Int | Diamond Int\n  deriving Show\n")),(0,r.kt)("h2",{id:"type-parameters"},"Type Parameters"),(0,r.kt)("h3",{id:"defining-parameterized-types"},"Defining Parameterized Types"),(0,r.kt)("p",null,"This is our first own parameterized type ",(0,r.kt)("inlineCode",{parentName:"p"},"Descripbed"),", which values ",(0,r.kt)("inlineCode",{parentName:"p"},"Described a")," contain a value of type ",(0,r.kt)("inlineCode",{parentName:"p"},"a")," and a ",(0,r.kt)("inlineCode",{parentName:"p"},"String")," description."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"data Described a = Describe a String\n\ngetValue :: Described a -> a\ngetValue (Describe x _) = x\n\ngetDescription :: Described a -> String\ngetDescription (Describe _ desc) = desc\n")),(0,r.kt)("h3",{id:"syntactic-note"},"Syntactic Note"),(0,r.kt)("p",null,"The rules for Haskell identifiers are:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Type variables and names for functions and values start lower case."),(0,r.kt)("li",{parentName:"ul"},"Type names and constructor names start with upper case.")),(0,r.kt)("h3",{id:"multiple-type-parameters"},"Multiple Type Parameters"),(0,r.kt)("p",null,"Types can have multiple type parameters:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"data Either a b = Left a | Right b\n")),(0,r.kt)("h2",{id:"recursive-types"},"Recursive Types"),(0,r.kt)("p",null,"Just lke Haskell functions, Haskell data types can be ",(0,r.kt)("inlineCode",{parentName:"p"},"recursive"),". This is how you define a list of integers:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"data IntList = Empty | Node Int IntList\n  deriving Show\n\nihead :: IntList -> Int\nihead (Node i _) = i\n\nitail :: IntList -> IntList\nitail (Node _ t) = t\n\nilength :: IntList -> Int\nilength Empty = 0\nilength (Node _ t) = 1 + ilength t\n")),(0,r.kt)("p",null,"We can use the functions defined above to work with lists of integers:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"Prelude> ihead (Node 3 (Node 5 (Node 4 Empty)))\n3\nPrelude> itail (Node 3 (Node 5 (Node 4 Empty)))\nNode 5 (Node 4 Empty)\nPrelude> ilength (Node 3 (Node 5 (Node 4 Empty)))\n3\n")),(0,r.kt)("p",null,"To be able to put any type of element in our list, you can use:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"data List a = Empty | Node a (List a)\n  deriving Show\n")),(0,r.kt)("h2",{id:"record-syntax"},"Record Syntax"),(0,r.kt)("p",null,"Haskell has a feature called ",(0,r.kt)("inlineCode",{parentName:"p"},"record syntax")," that is helper for you to get value from those fields, so you don't need to remember the order of each parameter."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"data Person = MkPerson { name :: String, age :: Int, town :: String, state :: String, profession :: String}\n  deriving Show\n")),(0,r.kt)("p",null,"You can both define values of ",(0,r.kt)("inlineCode",{parentName:"p"},"Person")," normally or using record syntax:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},'Prelude> MkPerson "Jane Doe" 21 "Houston" "Texas" "Engineer"\nMkPerson {name = "Jane Doe", age = 21, town = "Houston", state = "Texas", profession = "Engineer"}\n\nPrelude> MkPerson {name = "Jane Doe", town = "Houston", profession = "Engineer", state = "Texas", age = 21}\nMkPerson {name = "Jane Doe", age = 21, town = "Houston", state = "Texas", profession = "Engineer"}\n')),(0,r.kt)("p",null,"You are free to get accesoor functions for the fields."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},'Prelude> :t profession\nprofession :: Person -> String\nPrelude> profession (MkPerson "Jane Doe" 21 "Houston" "Texas" "Engineer")\n"Engineer"\n')),(0,r.kt)("h2",{id:"other-ways-of-defining-types"},"Other Ways of Defining Types"),(0,r.kt)("p",null,"In addition to the ",(0,r.kt)("inlineCode",{parentName:"p"},"data")," keyword, there are two additional ways of defining types in Haskell."),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"newtype")," keyword works like ",(0,r.kt)("inlineCode",{parentName:"p"},"data"),", but you can only have a single constructor with a single field."),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"type")," keyword introduces a type alias."))}u.isMDXComponent=!0}}]);