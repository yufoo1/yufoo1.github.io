"use strict";(self.webpackChunkblog=self.webpackChunkblog||[]).push([[5159],{3905:(e,n,t)=>{t.d(n,{Zo:()=>p,kt:()=>m});var a=t(7294);function r(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function i(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function o(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?i(Object(t),!0).forEach((function(n){r(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):i(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function c(e,n){if(null==e)return{};var t,a,r=function(e,n){if(null==e)return{};var t,a,r={},i=Object.keys(e);for(a=0;a<i.length;a++)t=i[a],n.indexOf(t)>=0||(r[t]=e[t]);return r}(e,n);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)t=i[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(r[t]=e[t])}return r}var s=a.createContext({}),l=function(e){var n=a.useContext(s),t=n;return e&&(t="function"==typeof e?e(n):o(o({},n),e)),t},p=function(e){var n=l(e.components);return a.createElement(s.Provider,{value:n},e.children)},u="mdxType",d={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},f=a.forwardRef((function(e,n){var t=e.components,r=e.mdxType,i=e.originalType,s=e.parentName,p=c(e,["components","mdxType","originalType","parentName"]),u=l(t),f=r,m=u["".concat(s,".").concat(f)]||u[f]||d[f]||i;return t?a.createElement(m,o(o({ref:n},p),{},{components:t})):a.createElement(m,o({ref:n},p))}));function m(e,n){var t=arguments,r=n&&n.mdxType;if("string"==typeof e||r){var i=t.length,o=new Array(i);o[0]=f;var c={};for(var s in n)hasOwnProperty.call(n,s)&&(c[s]=n[s]);c.originalType=e,c[u]="string"==typeof e?e:r,o[1]=c;for(var l=2;l<i;l++)o[l]=t[l];return a.createElement.apply(null,o)}return a.createElement.apply(null,t)}f.displayName="MDXCreateElement"},5037:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>s,contentTitle:()=>o,default:()=>u,frontMatter:()=>i,metadata:()=>c,toc:()=>l});var a=t(7462),r=(t(7294),t(3905));const i={sidebar_position:2},o="Initialization and References",c={unversionedId:"cpp/Initialization and References",id:"cpp/Initialization and References",title:"Initialization and References",description:"Initialization",source:"@site/docs/cpp/Initialization and References.md",sourceDirName:"cpp",slug:"/cpp/Initialization and References",permalink:"/docs/cpp/Initialization and References",draft:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/cpp/Initialization and References.md",tags:[],version:"current",sidebarPosition:2,frontMatter:{sidebar_position:2},sidebar:"tutorialSidebar",previous:{title:"Types and Structs",permalink:"/docs/cpp/Types and Structs"},next:{title:"Streams",permalink:"/docs/cpp/Streams"}},s={},l=[{value:"Initialization",id:"initialization",level:2},{value:"Using <code>auto</code>",id:"using-auto",level:2},{value:"Structured Binding",id:"structured-binding",level:2},{value:"References",id:"references",level:2},{value:"Const and Const References",id:"const-and-const-references",level:2}],p={toc:l};function u(e){let{components:n,...t}=e;return(0,r.kt)("wrapper",(0,a.Z)({},p,t,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"initialization-and-references"},"Initialization and References"),(0,r.kt)("h2",{id:"initialization"},"Initialization"),(0,r.kt)("p",null,"There are multiple ways to initialize a pair:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},'std::pair<int, string> numSuffix1 = {1, "st"};\n\nstd::pair<int, string> numSuffix2;\nnumSuffix2.first = 2;\nnumSuffix2.second = "nd";\n\n\nstd::pair<int, string> numSuffix3 = std::make_pair(3, "rd");\n')),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"Uniform initialization")," is curly bracket initialization. Available for all types, immediate initialization on declaration."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},'std::vector<int> vec{1, 3, 5};\nstd::pair<int, string> numSuffix1{1, "st"};\nint x{5};\nstring f{"Ken"};\n')),(0,r.kt)("p",null,"Be careful with Vector initialization:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"std::vector<int> vec1(3, 5); // makes {5, 5, 5}, not {3, 5}\nstd::vector<int> vec2{3, 5}; // makes {3, 5};\n")),(0,r.kt)("h2",{id:"using-auto"},"Using ",(0,r.kt)("inlineCode",{parentName:"h2"},"auto")),(0,r.kt)("p",null,"Compiler can't deduce the type with no value provided. You shouldn't overuse ",(0,r.kt)("inlineCode",{parentName:"p"},"auto")," and you'd better type it out for simple types, but use it to reduce long type names."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},'int main() {\n    int a, b, c; // can\'t use auto\n    std::cin >> a >> b >> c;\n    auto result = quadratic(a, b, c);\n    bool found = result.first;\n    if(found) {\n        auto solutions = result.second;\n        std:: cout << solutions.first << solutions.second << endl;\n    } else {\n        std::cout << "No solutions found" << end;\n    }\n}\n')),(0,r.kt)("h2",{id:"structured-binding"},"Structured Binding"),(0,r.kt)("p",null,"Structured binding lets you initialize directly from the contents of a struct."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},'auto p = std::make_pair("s", 5);\n// before\nstring a = p.first;\nint b = p.second;\n\n// after\nauto [a, b] = p;\n')),(0,r.kt)("h2",{id:"references"},"References"),(0,r.kt)("p",null,"Reference is an alias for a named variable."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"void changeX(int& x) {\n    x = 0;\n}\n\nvoid keepX(int x) {\n    x = 0;\n}\n\nint a = 100;\nint b = 100;\n\nchangeX(a); // a becomes a reference to x\nkeepX(b); // b becomes a copy of x\n\n\ncout << a << endl // 0\ncout << b << endl // 100\n")),(0,r.kt)("p",null,"Remember, ",(0,r.kt)("inlineCode",{parentName:"p"},"=")," automatically makes a copy. You can use ",(0,r.kt)("inlineCode",{parentName:"p"},"&")," to avoid this."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"vector<int> original{1, 2};\nvector<int> copy = original;\nvector<int>& ref = original;\noriginal.push_back(3);\ncopy.push_back(4);\nref.push_back(5);\n\ncout << original << endl; // 1, 2, 3, 5\ncout << copy << endl; // 1, 2, 4\ncout << ref << endl; // 1, 2, 3, 5\n")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"l-values")," can appear on the ",(0,r.kt)("inlineCode",{parentName:"p"},"left or right")," of an ",(0,r.kt)("inlineCode",{parentName:"p"},"="),", which have names and are ",(0,r.kt)("inlineCode",{parentName:"p"},"not temporary"),". ",(0,r.kt)("inlineCode",{parentName:"p"},"r-values")," can only appear on the ",(0,r.kt)("inlineCode",{parentName:"p"},"right")," of an ",(0,r.kt)("inlineCode",{parentName:"p"},"="),", which don't have names and are temporary. So ",(0,r.kt)("inlineCode",{parentName:"p"},"r-values")," can't be referenced. The following code is incorrect:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"void shift(vector<std::pair<int, int>>& nums) {\n    for(auto& [num1, num2]: nums) {\n        num1++;\n        num2++;\n    }\n}\n\n\nshift({{1, 1}}); // {{1, 1}} is an r-value, which can't be referenced\n\n\nauto my_nums = {{1, 1}};\nshift(my_nums); // correct\n")),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},"You can only create references to variables.")),(0,r.kt)("h2",{id:"const-and-const-references"},"Const and Const References"),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"const")," indivates a variable can't be modified."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"const std::vector<int> c_vec{1, 2};\nconst std::vector<int>& c_ref = vec;\n\nc_vec.push_back(3); // error\nc_ref.push_back(3); // error\n")),(0,r.kt)("p",null,"You can't declase non-const reference to const variable."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"const std::vector<int> c_vec{1, 2};\n\nstd::vector<int>& bad_ref = c_vec; // error\n")),(0,r.kt)("p",null,"C++, by default, makes copies when we do variable assignment. We need to use ",(0,r.kt)("inlineCode",{parentName:"p"},"&")," if we need references instead."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"std::vector<int> vec{1, 2, 3};\nconst std::vector<int> c_vec{7, 8};\n\nstd::vector<int>& ref = vec;\nconst std::vector<int>& c_ref = vec;\n\nauto copy = c_ref // non-const copy\nconst auto c_copy = c_ref // const copy\nauto& a_ref = ref; // non-const reference\nconst auto& c_aref = ref // const reference\n")),(0,r.kt)("p",null,"You can return references as well:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"int& front(std::vector<int>& vec) {\n    return vec[0]; // assuming vec.size() > 0\n}\n\n\nint main() {\n    std::vector<int> numbers{1, 2, 3};\n    front(numbers) = 4; // vec = {4, 2, 3}\n    return 0;\n}\n")))}u.isMDXComponent=!0}}]);