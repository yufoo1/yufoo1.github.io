"use strict";(self.webpackChunkblog=self.webpackChunkblog||[]).push([[4495],{3905:(e,n,t)=>{t.d(n,{Zo:()=>p,kt:()=>k});var a=t(7294);function l(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function r(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function i(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?r(Object(t),!0).forEach((function(n){l(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):r(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function o(e,n){if(null==e)return{};var t,a,l=function(e,n){if(null==e)return{};var t,a,l={},r=Object.keys(e);for(a=0;a<r.length;a++)t=r[a],n.indexOf(t)>=0||(l[t]=e[t]);return l}(e,n);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)t=r[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(l[t]=e[t])}return l}var s=a.createContext({}),u=function(e){var n=a.useContext(s),t=n;return e&&(t="function"==typeof e?e(n):i(i({},n),e)),t},p=function(e){var n=u(e.components);return a.createElement(s.Provider,{value:n},e.children)},c="mdxType",m={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},d=a.forwardRef((function(e,n){var t=e.components,l=e.mdxType,r=e.originalType,s=e.parentName,p=o(e,["components","mdxType","originalType","parentName"]),c=u(t),d=l,k=c["".concat(s,".").concat(d)]||c[d]||m[d]||r;return t?a.createElement(k,i(i({ref:n},p),{},{components:t})):a.createElement(k,i({ref:n},p))}));function k(e,n){var t=arguments,l=n&&n.mdxType;if("string"==typeof e||l){var r=t.length,i=new Array(r);i[0]=d;var o={};for(var s in n)hasOwnProperty.call(n,s)&&(o[s]=n[s]);o.originalType=e,o[c]="string"==typeof e?e:l,i[1]=o;for(var u=2;u<r;u++)i[u]=t[u];return a.createElement.apply(null,i)}return a.createElement.apply(null,t)}d.displayName="MDXCreateElement"},4098:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>s,contentTitle:()=>i,default:()=>c,frontMatter:()=>r,metadata:()=>o,toc:()=>u});var a=t(7462),l=(t(7294),t(3905));const r={sidebar_position:1},i="Simple Features of Haskell",o={unversionedId:"haskell/Simple Features of Haskell",id:"haskell/Simple Features of Haskell",title:"Simple Features of Haskell",description:"Haskell",source:"@site/docs/haskell/Simple Features of Haskell.md",sourceDirName:"haskell",slug:"/haskell/Simple Features of Haskell",permalink:"/docs/haskell/Simple Features of Haskell",draft:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/haskell/Simple Features of Haskell.md",tags:[],version:"current",sidebarPosition:1,frontMatter:{sidebar_position:1},sidebar:"tutorialSidebar",previous:{title:"Haskell",permalink:"/docs/category/haskell"},next:{title:"Recursion and Helper Functions",permalink:"/docs/haskell/Recursion and Helper Functions"}},s={},u=[{value:"Haskell",id:"haskell",level:2},{value:"Features",id:"features",level:2},{value:"Expressions and Types",id:"expressions-and-types",level:2},{value:"Structure of Haskell Program",id:"structure-of-haskell-program",level:2},{value:"Basic Building Block",id:"basic-building-block",level:2},{value:"Conditional",id:"conditional",level:3},{value:"Local Definition",id:"local-definition",level:2},{value:"Immutability",id:"immutability",level:3},{value:"Pattern Matching",id:"pattern-matching",level:3},{value:"Recursion",id:"recursion",level:3},{value:"Indentation",id:"indentation",level:2}],p={toc:u};function c(e){let{components:n,...t}=e;return(0,l.kt)("wrapper",(0,a.Z)({},p,t,{components:n,mdxType:"MDXLayout"}),(0,l.kt)("h1",{id:"simple-features-of-haskell"},"Simple Features of Haskell"),(0,l.kt)("h2",{id:"haskell"},"Haskell"),(0,l.kt)("p",null,"Hashkell is:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"Functional: The basic building blocks of programs are functions.")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"Pure: Haskell functions don't have side effects.")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"Lazy: Values are only evaluated when they are needed.")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"Strongly typed: Every Haskell value, expression has a type and the compiler checks the types at compile-time.")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"Type inferred: Most Haskell functions can be written completely without types.")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"Garbage-collected: Haskell has automatic memory management via garbage collection.")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"Compiled: Haskell is a compiled language."))),(0,l.kt)("h2",{id:"features"},"Features"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"Higher-order functions: Functions can take functions as arguments."),(0,l.kt)("li",{parentName:"ul"},"Anonymous functions aka lambdas: You can define single-use helper functions without giving them a name."),(0,l.kt)("li",{parentName:"ul"},"Partial application: You can define new functions by giving another function only some of the arguments it needs."),(0,l.kt)("li",{parentName:"ul"},"Algebraic datatypes: A syntax for defining datatypes that can contain a number of different cases."),(0,l.kt)("li",{parentName:"ul"},"Pattern matching: Defining functions based on cases that correspond to your data definitions."),(0,l.kt)("li",{parentName:"ul"},"Lists: Haskell has a concise built-in syntax for lists."),(0,l.kt)("li",{parentName:"ul"},"Parameterized types: You can define types that are parameterized by other type."),(0,l.kt)("li",{parentName:"ul"},"Type classes: Another form of polymorphism where you can give a function a different implementation depending on the arguments' types.")),(0,l.kt)("h2",{id:"expressions-and-types"},"Expressions and Types"),(0,l.kt)("p",null,"Almost everything in a Haskell program is an expression. An expression has a value an a type. Parentheses can be used to group expressions. "),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-haskell"},"g h f 1         -- g(h, f, 1)\ng h (f 1)   -- g(h, f(1))\ng (h f 1)   -- g(h(f, 1))\ng (h (f 1)) -- g(h(f(1)))\n")),(0,l.kt)("p",null,"Some function names are made special characters and they are used as operators: between their arguments instead of before them."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-haskell"},"a + b               -- a + b\nf a + g b       -- f(a) + g(b)\nf (a + g b) -- f(a + g(b))\n")),(0,l.kt)("blockquote",null,(0,l.kt)("p",{parentName:"blockquote"},"In Haskell, function application associates left, that is ",(0,l.kt)("inlineCode",{parentName:"p"},"f g x y")," is actually the same as ",(0,l.kt)("inlineCode",{parentName:"p"},"(((f g) x) y)"),".")),(0,l.kt)("h2",{id:"structure-of-haskell-program"},"Structure of Haskell Program"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-haskell"},"module Gold where\n\nphi :: Double -- definition of constant phi\nphi = (sqrt 5 + 1) / 2\n\npoly :: Double -> Double -- definition of poly\npoly x = x ^ 2 - x - 1\n\nf x = poly (poly x) -- lack of type annotation.\n\nmain = do\n    print(polynomal phi)\n    print(f phi)\n")),(0,l.kt)("p",null,"For a multi-line definition in ",(0,l.kt)("inlineCode",{parentName:"p"},"GHCi"),", you should use ",(0,l.kt)("inlineCode",{parentName:"p"},";")," to separate lines, or use the special ",(0,l.kt)("inlineCode",{parentName:"p"},":{ :}")," syntax to paste a block of code into it."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-haskell"},"ghci> :{\nghci| poly :: Double -> Double\nghci| poly x = x ^ 2 - x - 1\nghci| :}\n")),(0,l.kt)("h2",{id:"basic-building-block"},"Basic Building Block"),(0,l.kt)("h3",{id:"conditional"},"Conditional"),(0,l.kt)("p",null,"In Haskell, ",(0,l.kt)("inlineCode",{parentName:"p"},"if")," is an expression, which means it has a value. It selects between two other expressions and you always need an else."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-haskell"},"price = if product == 'milk' then 1 else 2\n")),(0,l.kt)("h2",{id:"local-definition"},"Local Definition"),(0,l.kt)("p",null,"Haskell has two different ways for creating local definitions: ",(0,l.kt)("inlineCode",{parentName:"p"},"let ... in")," and ",(0,l.kt)("inlineCode",{parentName:"p"},"where"),"."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-haskell"},"circleArea :: Double -> Double\ncircleArea r = pi * rsquare\n    where pi = 3.1415926\n                rsquare = r * r\n")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-haskell"},"circleArea r = let pi = 3.1415926\n                                     rsquare = r * r\n                             in pi * rsquare\n")),(0,l.kt)("h3",{id:"immutability"},"Immutability"),(0,l.kt)("p",null,"The values of definitions in Haskell can't be changed."),(0,l.kt)("h3",{id:"pattern-matching"},"Pattern Matching"),(0,l.kt)("p",null,"A definition can consist of multiple equations. The equations are matched in order against the arguments until a suitable one is found."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-haskell"},'greet :: String -> String -> String\ngreet "Finland" name = "Hei, " ++ name\ngreet "Italy"   name = "Ciao, " ++ name\ngreet "England" name = "How do you do, " ++ name\ngreet _         name = "Hello, " ++ name\n')),(0,l.kt)("p",null,"You can also pattern match on multiple arguments and the equations are tried in order."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-haskell"},'login :: String -> String -> String\nlogin "unicorn73" "f4bulous!" = "unicorn73 logged in"\nlogin "unicorn73" _           = "wrong password"\nlogin _           _           = "unknown user"\n')),(0,l.kt)("h3",{id:"recursion"},"Recursion"),(0,l.kt)("p",null,"In Haskell, all sorts of loops are implemented with recursion."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-haskell"},"factorial :: Int -> Int\nfactorial 1 = 1\nfactorial n = n * factorial (n-1)\n")),(0,l.kt)("h2",{id:"indentation"},"Indentation"),(0,l.kt)("p",null,"In Haskell, indentation matters:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"Things that are grouped together start from the same column."),(0,l.kt)("li",{parentName:"ul"},"If an expression or equation has to be split on to many lines, increase indentation.")))}c.isMDXComponent=!0}}]);