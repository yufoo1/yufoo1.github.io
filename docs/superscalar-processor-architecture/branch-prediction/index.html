<!doctype html>
<html lang="en" dir="ltr" class="docs-wrapper docs-doc-page docs-version-current plugin-docs plugin-id-default docs-doc-id-superscalar-processor-architecture/branch-prediction">
<head>
<meta charset="UTF-8">
<meta name="generator" content="Docusaurus v2.2.0">
<title data-rh="true">分支预测 | yufoo1&#x27;s Site</title><meta data-rh="true" name="viewport" content="width=device-width,initial-scale=1"><meta data-rh="true" name="twitter:card" content="summary_large_image"><meta data-rh="true" property="og:url" content="https://yufoo1.github.io/docs/superscalar-processor-architecture/branch-prediction"><meta data-rh="true" name="docusaurus_locale" content="en"><meta data-rh="true" name="docsearch:language" content="en"><meta data-rh="true" name="docusaurus_version" content="current"><meta data-rh="true" name="docusaurus_tag" content="docs-default-current"><meta data-rh="true" name="docsearch:version" content="current"><meta data-rh="true" name="docsearch:docusaurus_tag" content="docs-default-current"><meta data-rh="true" property="og:title" content="分支预测 | yufoo1&#x27;s Site"><meta data-rh="true" name="description" content="随着处理器并行度的提高以及流水线的加深，静态分支预测算法已经不能够满足复杂处理器对性能的要求，需要更准确的分支预测方法，能够根据处理器实际的执行情况，动态地对分支指令进行预测。动态分支预测并不简单地预测分支指令一直发生跳转或者不跳转，而是会根据分支指令在过去一段时间的执行情况来决定预测的结果。"><meta data-rh="true" property="og:description" content="随着处理器并行度的提高以及流水线的加深，静态分支预测算法已经不能够满足复杂处理器对性能的要求，需要更准确的分支预测方法，能够根据处理器实际的执行情况，动态地对分支指令进行预测。动态分支预测并不简单地预测分支指令一直发生跳转或者不跳转，而是会根据分支指令在过去一段时间的执行情况来决定预测的结果。"><link data-rh="true" rel="icon" href="/img/favicon.ico"><link data-rh="true" rel="canonical" href="https://yufoo1.github.io/docs/superscalar-processor-architecture/branch-prediction"><link data-rh="true" rel="alternate" href="https://yufoo1.github.io/docs/superscalar-processor-architecture/branch-prediction" hreflang="en"><link data-rh="true" rel="alternate" href="https://yufoo1.github.io/docs/superscalar-processor-architecture/branch-prediction" hreflang="x-default"><link rel="alternate" type="application/rss+xml" href="/blog/rss.xml" title="yufoo1&#39;s Site RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/blog/atom.xml" title="yufoo1&#39;s Site Atom Feed">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.13.24/dist/katex.min.css" integrity="sha384-odtC+0UGzzFL/6PNoE8rX/SPcQDXBJ+uRepguP4QkPCm2LBxH3FA3y+fKSiJ+AmM" crossorigin="anonymous"><link rel="stylesheet" href="/assets/css/styles.793b1a00.css">
<link rel="preload" href="/assets/js/runtime~main.9657dcaa.js" as="script">
<link rel="preload" href="/assets/js/main.b62e56eb.js" as="script">
</head>
<body class="navigation-with-keyboard">
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){var t=null;try{t=localStorage.getItem("theme")}catch(t){}return t}();t(null!==e?e:"light")}()</script><div id="__docusaurus">
<div role="region" aria-label="Skip to main content"><a class="skipToContent_fXgn" href="#docusaurus_skipToContent_fallback">Skip to main content</a></div><nav class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Toggle navigation bar" aria-expanded="false" class="navbar__toggle clean-btn" type="button"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/"><div class="navbar__logo"><img src="/img/logo.svg" alt="My Site Logo" class="themedImage_ToTc themedImage--light_HNdA"><img src="/img/logo.svg" alt="My Site Logo" class="themedImage_ToTc themedImage--dark_i4oU"></div><b class="navbar__title text--truncate">yufoo1&#x27;s Site</b></a><a aria-current="page" class="navbar__item navbar__link navbar__link--active" href="/docs/intro">Tutorial</a></div><div class="navbar__items navbar__items--right"><a href="https://github.com/yufoo1" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a><div class="searchBox_ZlJk"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div id="docusaurus_skipToContent_fallback" class="main-wrapper mainWrapper_z2l0 docsWrapper_BCFX"><button aria-label="Scroll back to top" class="clean-btn theme-back-to-top-button backToTopButton_sjWU" type="button"></button><div class="docPage__5DB"><aside class="theme-doc-sidebar-container docSidebarContainer_b6E3"><div class="sidebar_njMd"><nav class="menu thin-scrollbar menu_SIkG"><ul class="theme-doc-sidebar-menu menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/docs/intro">Tutorial Intro</a></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--active" aria-expanded="true" href="/docs/category/超标量处理器">超标量处理器</a><button aria-label="Toggle the collapsible sidebar category &#x27;超标量处理器&#x27;" type="button" class="clean-btn menu__caret"></button></div><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/superscalar-processor-architecture/pipeline">流水线</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/superscalar-processor-architecture/cache">Cache</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/superscalar-processor-architecture/virtual-memory">虚拟存储器</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link menu__link--active" aria-current="page" tabindex="0" href="/docs/superscalar-processor-architecture/branch-prediction">分支预测</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/superscalar-processor-architecture/isa">指令集体系</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/superscalar-processor-architecture/decode">指令解码</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/superscalar-processor-architecture/register-renaming">寄存器重命名</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/superscalar-processor-architecture/issue">发射</a></li></ul></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" aria-expanded="false" href="/docs/category/python-网络爬虫">Python 网络爬虫</a><button aria-label="Toggle the collapsible sidebar category &#x27;Python 网络爬虫&#x27;" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" aria-expanded="false" href="/docs/category/java-虚拟机">Java 虚拟机</a><button aria-label="Toggle the collapsible sidebar category &#x27;Java 虚拟机&#x27;" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" aria-expanded="false" href="/docs/category/机器学习">机器学习</a><button aria-label="Toggle the collapsible sidebar category &#x27;机器学习&#x27;" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" aria-expanded="false" href="/docs/category/webapp-development">Web/App Development</a><button aria-label="Toggle the collapsible sidebar category &#x27;Web/App Development&#x27;" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" aria-expanded="false" href="/docs/category/risc-v-操作系统移植">Risc-V 操作系统移植</a><button aria-label="Toggle the collapsible sidebar category &#x27;Risc-V 操作系统移植&#x27;" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" aria-expanded="false" href="/docs/category/design-pattern-in-cpu">Design Pattern in CPU</a><button aria-label="Toggle the collapsible sidebar category &#x27;Design Pattern in CPU&#x27;" type="button" class="clean-btn menu__caret"></button></div></li></ul></nav></div></aside><main class="docMainContainer_gTbr"><div class="container padding-top--md padding-bottom--lg"><div class="row"><div class="col docItemCol_VOVn"><div class="docItemContainer_Djhp"><article><nav class="theme-doc-breadcrumbs breadcrumbsContainer_Z_bl" aria-label="Breadcrumbs"><ul class="breadcrumbs" itemscope="" itemtype="https://schema.org/BreadcrumbList"><li class="breadcrumbs__item"><a aria-label="Home page" class="breadcrumbs__link" href="/"><svg viewBox="0 0 24 24" class="breadcrumbHomeIcon_OVgt"><path d="M10 19v-5h4v5c0 .55.45 1 1 1h3c.55 0 1-.45 1-1v-7h1.7c.46 0 .68-.57.33-.87L12.67 3.6c-.38-.34-.96-.34-1.34 0l-8.36 7.53c-.34.3-.13.87.33.87H5v7c0 .55.45 1 1 1h3c.55 0 1-.45 1-1z" fill="currentColor"></path></svg></a></li><li itemscope="" itemprop="itemListElement" itemtype="https://schema.org/ListItem" class="breadcrumbs__item"><a class="breadcrumbs__link" itemprop="item" href="/docs/category/超标量处理器"><span itemprop="name">超标量处理器</span></a><meta itemprop="position" content="1"></li><li itemscope="" itemprop="itemListElement" itemtype="https://schema.org/ListItem" class="breadcrumbs__item breadcrumbs__item--active"><span class="breadcrumbs__link" itemprop="name">分支预测</span><meta itemprop="position" content="2"></li></ul></nav><div class="tocCollapsible_ETCw theme-doc-toc-mobile tocMobile_ITEo"><button type="button" class="clean-btn tocCollapsibleButton_TO0P">On this page</button></div><div class="theme-doc-markdown markdown"><h1>分支预测</h1><p>随着处理器并行度的提高以及流水线的加深，静态分支预测算法已经不能够满足复杂处理器对性能的要求，需要更准确的分支预测方法，能够根据处理器实际的执行情况，动态地对分支指令进行预测。动态分支预测并不简单地预测分支指令一直发生跳转或者不跳转，而是会根据分支指令在过去一段时间的执行情况来决定预测的结果。</p><p>要进行分支预测，首先需要知道从<code>I-Cache</code>取出来的指令中，哪条是分支指令，对于每周期取出多条指令的超标量处理器来说，这需要从指令组<code>fetch group</code>中找出分支指令。从指令组中的指令从<code>I-Cache</code>取出来之后，可以进行快速的解码，这只需要辨别解码指令是否是分支指令，然后将找到的分支指令对应的<code>PC</code>值送到分支预测器，就可以对分支指令进行预测了：</p><p><img loading="lazy" src="/assets/images/59-d1c50549cddae15629d851bc9cbebdfb.png" width="1144" height="520" class="img_ev3q"></p><p>然而，由于<code>I-Cache</code>的访问可能需要多个周期才可以完成，采用上图所示的方式进行分支预测，从开始取指令直到分支预测得到结果，中间需要间隔好几个周期，在这些周期内无法得到准确的预测结果，只能够顺序地取指令，也就相当于这些周期都是预测分支指令不发生跳转，这样就降低了分支预测的准确度，造成了处理器性能的降低。</p><p>在流水线中，分支预测是越靠前越好的，因此分支预测的最好时机就是在当前周期得到取指令地址的时候，在取指令的同时进行分支预测，这样在下个周期就可以根据预测的结果继续取指令。对于一条指令来说，它的物理地址是会变化的（这取决于操作系统将它放到物理内存的位置），而它的虚拟地址，也就是<code>PC</code>值，是不会变化的。因为在一个进程内，每一个<code>PC</code>值对应的指令是固定的，不可能出现一个<code>PC</code>值对应多条指令的情况，所以使用<code>PC</code>值进行分支预测，只不过在进行进程切换之后，需要将分支预测器中的内容进行情况，这样可以保证不同进程之间的分支预测不会互相干扰，如果使用了<code>ASID</code>，那么可以将它和<code>PC</code>值一起进行分支预测，此时就不需要在进程切换时情况分支预测器了，这个过程如图所示：</p><p><img loading="lazy" src="/assets/images/60-45eab2b277c907e624725eff203788f2.png" width="1202" height="516" class="img_ev3q"></p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="分支指令的方向预测">分支指令的方向预测<a class="hash-link" href="#分支指令的方向预测" title="Direct link to heading">​</a></h2><p>对于分支指令来说，它的方向只有两个：发生跳转<code>taken</code>和不发生跳转<code>not taken</code>，因此可以用<code>1</code>和<code>0</code>来表示。</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="根据最后一次结果进行预测">根据最后一次结果进行预测<a class="hash-link" href="#根据最后一次结果进行预测" title="Direct link to heading">​</a></h3><p>该方法直接使用上次分支的结果：</p><p><img loading="lazy" src="/assets/images/61-8729567f7435a10556a8b8e0ecf14c57.png" width="726" height="278" class="img_ev3q"></p><p>但是如果分支指令的方向每次都发生变化，则使用最后一次指令的结果进行分支预测的方法，它的失败率将是<code>100%</code>。</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="基于两位饱和计数器的分支预测">基于两位饱和计数器的分支预测<a class="hash-link" href="#基于两位饱和计数器的分支预测" title="Direct link to heading">​</a></h3><p>基于两位饱和计数器的分支预测并不会马上使用分支指令上一次的结果，而是根据一条分支指令前两次执行的结果来预测本次的方向，这种方法可以用一个有着<code>4</code>个状态的状态机来表示，这四个状态分别如下：</p><ol><li><code>Strongly taken</code>：计数器处于饱和状态，分支指令本次会被预测发生跳转，编码为<code>11</code>；</li><li><code>Weakly taken</code>：计时器处于不饱和状态，分支指令本次会预测发生跳转，编码为<code>10</code>；</li><li><code>Weakly not taken</code>：计数器处于不饱和状态，分支指令本次会预测不发生跳转，编码为<code>01</code>；</li><li><code>Strongly not taken</code>：计数器处于饱和状态，分支指令本次会被预测不发生跳转，编码为<code>00</code>。</li></ol><p>整个状态机如图所示：</p><p><img loading="lazy" src="/assets/images/62-31beddc9612e8e6b51f1fd0439f48a98.png" width="1040" height="252" class="img_ev3q"></p><p>可以使用格雷码对状态机进行编码，保证在状态转换时每次只有一位发生变化，这样可以减少出错的概率，并降低功耗。</p><p>分支预测都是以<code>PC</code>值为基础进行的，正常来说，每一个<code>PC</code>值都应该对应一个两位的饱和计数器，因此，对于<code>32</code>位的<code>PC</code>值来说，共需要<span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>30</mn></msup><mo>×</mo><mn>2</mn><mi>b</mi></mrow><annotation encoding="application/x-tex">2^{30}\times 2b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8974em;vertical-align:-0.0833em"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em"><span style="top:-3.063em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">30</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em"></span></span><span class="base"><span class="strut" style="height:0.6944em"></span><span class="mord">2</span><span class="mord mathnormal">b</span></span></span></span></span>但是实际芯片当中无法使用这样大的存储器。考虑到并不是所有的指令都是分支指令，一般使用下图所示的方法来存储两位饱和计数器的值：</p><p><img loading="lazy" src="/assets/images/63-37123413fa0e3204dc6cf7ae9483c833.png" width="992" height="446" class="img_ev3q"></p><p>在上图中，<code>PHT</code>是一个表格，这个<code>PHT</code>使用<code>PC</code>值的一部分来寻址，但是，使用这种方式来寻址<code>PHT</code>，必然就导致了<code>k</code>部分相同的所有<code>PC</code>值都使用同一个两位饱和计数器的值，如果这些<code>PC</code>值对应的指令中不止有一条分支指令，那么相互之间肯定会产生干扰，这种情况称为<code>别名（aliasing）</code>。但是考虑到这个方法实现起来比较容易，而且占用的存储器资源也不大，因此轻微的预测准确度降低也是能够接受的。</p><p>在基于两位饱和计数器的分支预测方法中，别名会降低分支预测的准确度，可以采用一些更高级的方法来避免别名情况的发生，比较典型的方法就是使用<code>哈希</code>，对<code>PC</code>值进行处理之后再去寻址<code>PHT</code>，这个过程如图所示：</p><p><img loading="lazy" src="/assets/images/64-7127df5f963877a43e498493f7f311f3.png" width="856" height="446" class="img_ev3q"></p><p>上图的哈希算法能够将<code>32</code>位的<code>PC</code>值压缩为固定长度的较小的值，这个小的值称为哈希值，在计算机算法领域中，哈希指的就是把任意长度的输入值，通过哈希算法，变为固定长度的输出，一般输出值的长度远小于输入值的长度。哈希算法的实现可以很简单，例如使用普通的异或逻辑，当然为了得到好的效果，也可以做得很复杂。</p><p>两位的饱和计数器需要根据分支指令的结果（发生跳转或者不发生跳转）进行更新，有三个时间点可以对<code>PHT</code>进行更新：</p><ol><li>在流水线的取指令阶段，进行分支预测时，根据预测的结果来更新<code>PHT</code>；</li><li>在流水线的执行阶段，当分支指令的方向被实际计算出来时，更新<code>PHT</code>；</li><li>在流水线的<code>Commit</code>阶段，当分支指令要离开流水线时，更新<code>PHT</code>。</li></ol><p>对于第一种方法，因为此时分支预测的结果可能是错误的，使用错误的结果来更新<code>PHT</code>是不可靠的。</p><p>对于第二种方法，如果对分支指令采用了乱序执行的方式，那么即使在指令阶段得到了一条分支指令的结果，也不能够保证这个结果是正确的，因为这条分支指令可能处于分支预测失败的路径上。</p><p>对于第三种方法，在分支指令被确认已经正确执行的时候，更新<code>PHT</code>是万无一失的，而考虑到饱和计数器的特点，只要计数器处于饱和状态，它的预测值就会比较固定，因此即使更新<code>PHT</code>的时间晚一些，也不会对分支预测的精度产生太大的负面影响。</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="基于局部历史的分支预测">基于局部历史的分支预测<a class="hash-link" href="#基于局部历史的分支预测" title="Direct link to heading">​</a></h3><p>在这种方法中，会使用一个寄存器来记录一条分支指令在过去的历史状态，当这个历史状态很有规律时，就可以为分支预测提供一个可以利用的工具，这样的寄存器称为分支历史寄存器<code>BHR</code>。对一条分支指令来说，通过将它每次的结果（发生跳转或者不发生跳转，用<code>1</code>或<code>0</code>表示）移入<code>BHR</code>寄存器，就可以记录这条分支指令的历史状态了，如果这条分支指令很有规律，那么就可以使用<code>BHR</code>寄存器对这条分支指令进行预测，这种分支预测的工作机制如图所示：</p><p><img loading="lazy" src="/assets/images/65-0093db273ee9b8be0ebc851ec620ab4b.png" width="826" height="502" class="img_ev3q"></p><p>如果为每条分支指令都配一个<code>BHR</code>和<code>PHT</code>，这样需要很大的存储空间，将所有分支指令的<code>BHR</code>组合在一起称为分支历史寄存器表<code>BHT</code>，在实际当中，<code>BHT</code>不可能照顾到每个<code>PC</code>，一般都是使用<code>PC</code>的一部分来寻址<code>BHT</code>，如图所示：</p><p><img loading="lazy" src="/assets/images/66-d4608060b152723326024a4ec7eb6ed8.png" width="948" height="336" class="img_ev3q"></p><p>使用<code>PC</code>的一部分来寻址<code>BHT</code>，得到当前指令对应的分支历史寄存器<code>BHR</code>，设<code>BHR</code>的宽度为<code>n</code>位，则整个<code>BHT</code>所占的存储空间为<span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mi>k</mi></msup><mo>×</mo><mi>n</mi><mi>b</mi><mi>i</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">2^k\times nbit</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9324em;vertical-align:-0.0833em"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491em"><span style="top:-3.063em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em">k</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em"></span></span><span class="base"><span class="strut" style="height:0.6944em"></span><span class="mord mathnormal">nbi</span><span class="mord mathnormal">t</span></span></span></span></span>。</p><p>然而，这种方法可能存在两种冲突：</p><ol><li>两条分支指令的<code>PC</code>值对应的<code>k</code>部分相同，此时这两条分支指令就会对应到同一个<code>BHR</code>寄存器，也就对应到了<code>PHT</code>中的同一个饱和计数器，这样，两条分支指令的结果就会互相干扰，降低了分支预测的准确度。</li><li>两条分支指令虽然对应着两个不同的<code>BHR</code>，但是这两个<code>BHT</code>中的内容是一样的，这样两条分支指令也会共用<code>PHT</code>当中的同一个饱和计数器，也会降低分支预测的准确度。</li></ol><p>为了避免上述两种情况，可以将<code>PC</code>进行哈希处理之后，得到一个固定长度的值，再用词此值来寻址<code>BHT</code>，这样可以解决上面提到的情况一当中遇到的问题。从<code>BHT</code>中可以得到这条分支指令对应的<code>BHR</code>值，再将该<code>BHR</code>的值和<code>PC</code>值的一部分进行拼接，用得到的新值来寻址<code>PHT</code>，从而得到饱和计数器的值，也就是得到了分支预测的结果，这样可以解决上面提到的情况二当中遇到的情况。有多种方法可以将<code>PC</code>值和<code>BHR</code>值进行处理，如<code>位拼接法</code>和<code>异或法</code>。</p><p><img loading="lazy" src="/assets/images/67-9116781604ae8529b094276ab57a7be1.png" width="554" height="676" class="img_ev3q"></p><p><img loading="lazy" src="/assets/images/68-6b87e5d028ec076b4e522f8655d1ccd3.png" width="434" height="670" class="img_ev3q"></p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="基于全局历史的分支预测">基于全局历史的分支预测<a class="hash-link" href="#基于全局历史的分支预测" title="Direct link to heading">​</a></h3><p>如果对一条分支指令进行分支预测时，考虑到它前面的分支指令的执行结果，则称这种预测方法为基于全局历史的预测。在这种基于全局历史的分支预测方法中，需要一个寄存器来记录程序中所有的分支指令在过去的执行情况，这个寄存器被称为<code>全局历史寄存器（GHR）</code>。而<code>GHR</code>寄存器不可能记录下所有分支指令的执行结果，因此一般是使用一个有限位宽<code>GHR</code>，来记录最近执行的所有分支指令的结果，每当遇到一条分支指令时，就将这条分支指令的结果插入到<code>GHR</code>寄存器的右边，<code>1</code>表示发生了跳转，<code>0</code>表示没有发生跳转，<code>GHR</code>寄存器最左边被移出的位会被抛弃掉。</p><p>基于全局历史的分支预测方法，最理想的情况是对每条分支指令都使用一个<code>PHT</code>，这样每条分支指令都会使用当前的<code>GHR</code>来寻址自身对应的<code>PHT</code>，这种预测方法的示意图如图所示：</p><p><img loading="lazy" src="/assets/images/69-b4b97162aea26df36a6bceba87af97bd.png" width="768" height="414" class="img_ev3q"></p><p>但是这种方法在实际当中是无法使用的，为每个<code>PC</code>值都使用一个<code>PHT</code>会占据非常大的存储空间，因此一般都会使用<code>哈希法</code>将<code>PC</code>进行处理，得到位宽很小的值，这样<code>PHTs</code>就可以包含少量的<code>PHT</code>了，如图所示：</p><p><img loading="lazy" src="/assets/images/70-36155b6df40d3de1b216e240087a13e3.png" width="602" height="450" class="img_ev3q"></p><p>考虑到上面方法中，<code>PHT</code>中有很多饱和计数器都没有被使用，因此可以采取一种更简单的方式，即只使用一个<code>PHT</code>，如图所示：</p><p><img loading="lazy" src="/assets/images/71-5e49e3919f802ef6d97f2fbf240ffce0.png" width="536" height="388" class="img_ev3q"></p><p>上图所示的分支预测方法的缺点是如果两条不同的分支指令所对应的<code>GHR</code>值恰好相同的话，那么这两条分支指令就会共用<code>PHT</code>中同一个饱和计数器，这样就造成了冲突。为了解决这个问题，仍旧可以将<code>PC</code>值和<code>GHR</code>做一定的处理，比如<code>位拼接法</code>和<code>异或法</code>，使用处理之后的结果来寻址<code>PHT</code>，这样即使两条不同的分支指令对应同样的<code>GHR</code>的值，也不会对应到<code>PHT</code>中的同一个饱和计数器，避免了冲突的问题，如图所示：</p><p><img loading="lazy" src="/assets/images/72-6f4e42bd6a08110e206aadf976941f28.png" width="504" height="520" class="img_ev3q"></p><p><img loading="lazy" src="/assets/images/73-c9cbd9a6cc7858901e6a7f6c9f29f501.png" width="496" height="516" class="img_ev3q"></p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="竞争的分支预测">竞争的分支预测<a class="hash-link" href="#竞争的分支预测" title="Direct link to heading">​</a></h3><p>对于基于局部历史的分支预测和基于全局历史的分支预测，两种预测方法都有着自身的局限性，因此可以设计一种自适应的分支预测方法，根据不同的分支指令和执行情况自动地选择这两种分支预测方法，称为竞争的分支预测，如图所示为这种分支预测方法的原理图：</p><p><img loading="lazy" src="/assets/images/74-011c79765809d75bc5c8abacf426a898.png" width="614" height="510" class="img_ev3q"></p><p><code>P1</code>表示基于全局历史的分支预测方法，<code>P2</code>表示基于局部历史的分支预测方法，对于不同的分支指令会选择不同的预测方法。<code>CPHT</code>是由分支指令的<code>PC</code>值来寻址的一个表格，类似于<code>PHT</code>，它仍是由两位的饱和计数器组成的，当其中一种分支预测方法两次预测失败，而同时另外一种分支预测方法两次预测成功时，会使状态机转到使用另一个分支预测方法的状态，<code>CPHT</code>中每个饱和计数器的状态如图所示：</p><p><img loading="lazy" src="/assets/images/75-a2148bb82825e35fc3df5f62a8b067dc.png" width="566" height="388" class="img_ev3q"></p><p>该状态机的转换机制如下：</p><ol><li>当<code>P1</code>预测正确，<code>P2</code>预测错误时，计数器减<code>1</code>；</li><li>当<code>P1</code>预测错误，<code>P2</code>预测正确时，计数器加<code>1</code>；</li><li>当<code>P1</code>和<code>P2</code>预测的结果一样时，不管预测正确与否，计数器都保持不变。</li></ol><h3 class="anchor anchorWithStickyNavbar_LWe7" id="分支预测的更新">分支预测的更新<a class="hash-link" href="#分支预测的更新" title="Direct link to heading">​</a></h3><p>对于分支指令的方向预测来说，需要更新的内容包括两个方面：</p><ol><li>历史寄存器，在基于全局历史的分支预测方法中是<code>GHR</code>，在基于局部历史的分支预测中是<code>BHR</code>。</li><li>两位饱和计数器，基于全局历史和基于局部历史的分支预测方法均需要在<code>PHT</code>中使用饱和计数器来捕捉历史寄存器的规律，因此也需要对饱和计数器进行更新。</li></ol><h4 class="anchor anchorWithStickyNavbar_LWe7" id="更新历史寄存器">更新历史寄存器<a class="hash-link" href="#更新历史寄存器" title="Direct link to heading">​</a></h4><p>当分支指令到达流水线的<code>Commit</code>阶段，要离开流水线而退休时更新<code>GHR</code>是最保守的，但是会产生效率问题。假设一条分支指令<code>b</code>在时间<code>t</code>被分支预测，在时间<span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mo>+</mo><mi mathvariant="normal">Δ</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">t+\Delta t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6984em;vertical-align:-0.0833em"></span><span class="mord mathnormal">t</span><span class="mspace" style="margin-right:0.2222em"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em"></span></span><span class="base"><span class="strut" style="height:0.6833em"></span><span class="mord">Δ</span><span class="mord mathnormal">t</span></span></span></span></span>从流水线中退休并更新<code>GHR</code>，任何在<span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Δ</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">\Delta t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em"></span><span class="mord">Δ</span><span class="mord mathnormal">t</span></span></span></span></span>时间段之内被预测的分支指令，都不会从分支指令<code>b</code>的结果中获益，这就降低了分支预测的准确度。</p><p>当分支指令的方向在<code>执行</code>阶段被实际计算出来时更新<code>GHR</code>，会导致问题，因为如果对分支指令采用了乱序执行的方式，在执行阶段分支指令可能处于分支预测失败的错误路径中，即使是顺序执行分支指令的处理器，由于<code>异常</code>的处理需要清空流水线，分支指令在执行阶段的结果未必一定会写到<code>GHR</code>中，因此在执行阶段更新<code>GHR</code>也并不一定是正确的。</p><p>综合来看，最好在取指令阶段，根据分支预测的结果对<code>GHR</code>进行更新，这可以使后续的分支指令使用到最新的<code>GHR</code>，而且，当一条分支指令的分支预测失败时，即使后续的分支指令都使用了错误的<code>GHR</code>也不会产生影响，因为它们会被从流水线中清除。这种更新的<code>GHR</code>的方式在分支预测失败时，需要一种机制对<code>GHR</code>进行修复，使<code>GHR</code>能够恢复到正确的值，有如下两种修复方法。</p><h5 class="anchor anchorWithStickyNavbar_LWe7" id="commit阶段修复法">Commit阶段修复法<a class="hash-link" href="#commit阶段修复法" title="Direct link to heading">​</a></h5><p>在流水线的提交阶段防止一个<code>GHR</code>，每当一条分支指令退休的时候，就会将它的结果更新到这个<code>GHR</code>中，这个<code>GHR</code>称做<code>Retired GHR</code>，这样处理器中就有了两个<code>GHR</code>：在前端取指令阶段的<code>GHR</code>，它用来进行分支预测，采用了推测的方式进行更新；在后端提交阶段的<code>GHR</code>，每当一条分支指令退休的时候才会更新它，因此这个<code>GHR</code>肯定时正确的。当一条分支指令发现分支预测失败的时候，表明此时前端的<code>GHR</code>肯定是错误的，需要进行修复，此时只需要等待分支指令退休的时候，将后端的<code>GHR</code>写到前端的<code>GHR</code>中，就完成了前端<code>GHR</code>的修复，然后根据这条分支指令所指定的目标地址，重新取指令来执行即可。</p><p><img loading="lazy" src="/assets/images/76-2e5fad2eed661ef83d74ca83a61870fb.png" width="870" height="346" class="img_ev3q"></p><p>使用这种方法对<code>GHR</code>进行修复，缺点是会造成分支预测失败时惩罚的增大。</p><h5 class="anchor anchorWithStickyNavbar_LWe7" id="checkpoint修复法">Checkpoint修复法<a class="hash-link" href="#checkpoint修复法" title="Direct link to heading">​</a></h5><p>在取指令阶段对前端的<code>GHR</code>进行更新的同时，可以将旧的<code>GHR</code>值保存起来，这个保存的内容就称为<code>Checkpoint GHR</code>。一旦这条分支指令的结果在流水线中被计算出来，就可以对这条分支指令的分支预测是否正确进行检查了，如果发现分支预测正确，说明此时前端<code>GHR</code>中的值是正确的，那么继续执行就可以了；如果发现其分支预测失败，那么就将这条分支指令对应的<code>Checkpoint GHR</code>恢复到前端的<code>GHR</code>中，并从这条分支指令正确的目标地址开始取指令来执行，这个过程如图所示：</p><p><img loading="lazy" src="/assets/images/77-d74d21e66362c3718e74cd072ff4bfc0.png" width="812" height="566" class="img_ev3q"></p><p>由于分支预测发生在取指令阶段，此时指令之间仍然保持着顺序的方式，所以存储<code>Checkpoint GHR</code>的存储器只需要按照<code>FIFO</code>的方式进行写入就可以了；如果后续的流水线采用顺序的方式来执行分支指令，那么读取上述存储器也只需要按照<code>FIFO</code>的方式即可。而对于乱序执行分支指令的流水线来说，在执行阶段得到的分支指令的结果仍旧有可能是错误的，因为这条分支指令可能处于分支预测失败的路径上，也可能处于异常的路径上，所以仍旧需要在流水线的提交阶段对分支指令的预测是否正确进行检查。因此，在提交阶段仍需要放置一个<code>Retired GHR</code>，当分支指令退休的时候发现分支预测失败了，或者一条普通的指令发现了异常，都可以将此时的<code>Retired GHR</code>写回到前端的<code>GHR</code>中，这样就对<code>GHR</code>值进行了恢复。</p><p>在基于局部历史的分支预测方法中，可以在分支指令退休的时候更新<code>BHR</code>，这样可以简化设计，也不会对处理器的性能产生太大的负面影响。</p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="更新饱和计数器">更新饱和计数器<a class="hash-link" href="#更新饱和计数器" title="Direct link to heading">​</a></h4><p>在两种分支预测方法中，一般都是在分支指令退休的时候对<code>PHT</code>中的饱和计数器进行更新。</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="分支指令的目标预测">分支指令的目标预测<a class="hash-link" href="#分支指令的目标预测" title="Direct link to heading">​</a></h2><p>分支指令的目标地址可以分为两种，即直接跳转和间接跳转。对于直接跳转的分支指令，由于它的偏移值是以立即数的形式固定在指令当中，所以它的目标地址也是固定的，只要记录下这条分支指令的目标地址就可以了，当再次遇到这条分支指令时，如果方向预测的结果是发生跳转，那么它的目标地址就可以使用以前记录下的那个值；对于间接跳转的分支指令来说，由于它的目标地址来自于通用寄存器，因此进行目标地址的预测并不容易。然而，程序中大部分间接跳转类型的分支指令是用来处理子程序调用的<code>CALL</code>和<code>Return</code>指令，这两种指令的目标地址是有规律可循的，因此可以对其进行预测。</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="直接跳转类型的分支预测">直接跳转类型的分支预测<a class="hash-link" href="#直接跳转类型的分支预测" title="Direct link to heading">​</a></h3><h4 class="anchor anchorWithStickyNavbar_LWe7" id="byb">BYB<a class="hash-link" href="#byb" title="Direct link to heading">​</a></h4><p>对于直接跳转类型的分支指令来说，它的目标地址有两种情况。</p><ol><li>当分支指令不发生跳转时，<code>目标地址 = 当前分支指令的PC值 + Sizeof(fetch group)</code>。</li><li>当分支指令发生跳转时，<code>目标地址 = 当前分支指令的PC值 + Sign_extend(offset)</code>。</li></ol><p>由于分支预测是基于<code>PC</code>值进行的，不可能对每一个<code>PC</code>值都记录下它的目标地址，所以一般都是用<code>Cache</code>的形式，使多个<code>PC</code>值共用一个空间来存储目标地址，这个<code>Cache</code>称为<code>BTB</code>，<code>PC</code>的一部分作为<code>Index</code>来寻址<code>BTB</code>，<code>PC</code>值的其他部分作为<code>Tag</code>，<code>BTB</code>中存放着分支指令的目标地址<code>BTA</code>。</p><p>为了解决<code>Cache</code>冲突的问题，可以采用组相连结构的<code>BYB</code>，如图所示：</p><p><img loading="lazy" src="/assets/images/78-fee3699bcfcdb94d886bdf05fb9822ee.png" width="1290" height="694" class="img_ev3q"></p><p>由于组相连结构降低了<code>BTB</code>的访问速度，因此在现实世界的处理器中，<code>BTB</code>中<code>way</code>的个数一般都比较小。</p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="btb缺失的处理">BTB缺失的处理<a class="hash-link" href="#btb缺失的处理" title="Direct link to heading">​</a></h4><h5 class="anchor anchorWithStickyNavbar_LWe7" id="停止执行">停止执行<a class="hash-link" href="#停止执行" title="Direct link to heading">​</a></h5><p>对于直接跳转类型的分支指令，在流水线的解码阶段就可以从指令中分离出偏移值，此时就可以将这条分支指令的目标地址计算出来，这个过程的示意图如图所示：</p><p><img loading="lazy" src="/assets/images/79-2cba09cbe2717013c0c0099dabb4ef07.png" width="646" height="348" class="img_ev3q"></p><p>在分支指令的目标地址被计算出来之前，暂停取指令会导致流水线中出现一些气泡，如图所示：</p><p><img loading="lazy" src="/assets/images/80-bf191f4e9619aa915a4d9d7594e9d338.png" width="1022" height="334" class="img_ev3q"></p><h5 class="anchor anchorWithStickyNavbar_LWe7" id="继续执行">继续执行<a class="hash-link" href="#继续执行" title="Direct link to heading">​</a></h5><p>对于方向预测会发生跳转的分支指令来说，如果发生了<code>BTB</code>的缺失，此时可以使流水线继续使用顺序的<code>PC</code>值来取指令。之所以这样做，是考虑到分支指令的方向可能会预测错误，所以当<code>BTB</code>发生缺失时，采用顺序的<code>PC</code>值来取指令，也存在正确的可能性。</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="间接跳转类型的分支预测">间接跳转类型的分支预测<a class="hash-link" href="#间接跳转类型的分支预测" title="Direct link to heading">​</a></h3><h4 class="anchor anchorWithStickyNavbar_LWe7" id="callreturn指令的分支预测">CALL/Return指令的分支预测<a class="hash-link" href="#callreturn指令的分支预测" title="Direct link to heading">​</a></h4><p>在<code>MIPS</code>中，使用<code>JAL</code>指令作为<code>CALL</code>指令，而使用<code>JR $31</code>指令作为<code>Return</code>指令。对于程序中的一条指定的<code>CALL</code>指令来说，它每次调用的子程序都是固定的，也就是说，一条<code>CALL</code>指令对应的目标地址是固定的，因此可以使用<code>BTB</code>对<code>CALL</code>指令的目标地址进行预测，如图所示：</p><p><img loading="lazy" src="/assets/images/81-783241aece789f9566dc6c3f6afdabe6.png" width="682" height="344" class="img_ev3q"></p><p>因为<code>Return</code>指令的目标地址是不确定的，还因此无法使用<code>BTB</code>对它的目标地址进行预测，但是可以看出，<code>Return</code>指令的目标地址总是等于最近一次执行的<code>CALL</code>指令的下一条指令的地址，因此，可以设计一个存储器，保存最近执行的<code>CALL</code>指令的下一条指令的地址，这个存储器是后进先出的，即最后一次进入的数据将最先被使用，称为<code>RAS</code>。使用<code>BTB</code>对<code>CALL</code>指令的目标地址进行预测，使用<code>RAS</code>对<code>Return</code>指令的目标地址进行预测，过程如图所示：</p><p><img loading="lazy" src="/assets/images/82-1b4b276f47d17d1bf836917765952604.png" width="1078" height="422" class="img_ev3q"></p><p>为了在分支预测阶段通过<code>PC</code>判断一条指令是否是<code>CALL</code>指令，这需要借助于<code>BTB</code>，因为<code>BTB</code>中保存了所有发生跳转的分支指令，而<code>CALL\Return</code>指令都是永远会发生跳转的，因此它们都会保存在<code>BTB</code>中，这需要在<code>BTB</code>中增加一项，用来标记分支指令的类型，这样就可以在分支预测阶段识别出<code>CALL</code>指令，从而将<code>PC + 4</code>的值保存在<code>RAS</code>中。</p><p>当对<code>Return</code>指令进行目标地址预测的时候，需要能够选择<code>RAS</code>的输出作为目标地址的值，而不是选择<code>BTB</code>的输出值，因此仍需要在分支预测阶段就可以知道指令的类型。</p><p>因此，在<code>BTB</code>中，除了存储目标地址和<code>Tag</code>值之外，还需要存储分支指令的类型：</p><p><img loading="lazy" src="/assets/images/83-577fbc55b1ca939ff831ba3946a88783.png" width="660" height="234" class="img_ev3q"></p><p>在实际当中，如果一个程序中<code>CALL</code>指令嵌套很深，<code>RAS</code>已经满了时，有两种方法可以处理：</p><ol><li>不对新的<code>CALL</code>指令进行处理，此时不修改<code>RAS</code>，最后执行的这个<code>CALL</code>指令对应的返回地址就会被抛弃掉。</li><li>继续按照顺序向<code>RAS</code>中写入，此时<code>RAS</code>中最旧的那个内容就会被覆盖掉。由于存在递归函数调用的情况，所以这种方法存在正确的可能性。</li></ol><p>对于连续执行的同一个<code>CALL</code>指令来说，完全可以将它们的返回地址都放到<code>RAS</code>中的同一个地方，并用一个计数器来标记<code>CALL</code>指令执行的次数，这样相当于扩展了<code>RAS</code>的容量，增大了预测的准确度。</p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="其他预测方法">其他预测方法<a class="hash-link" href="#其他预测方法" title="Direct link to heading">​</a></h4><p>对于非<code>CALL/Return</code>的间接跳转类型的分支指令，它的目标地址也可能和过去的执行情况有关系，因此可以利用基于局部历史的分支预测方法中使用<code>BHR</code>对目标地址进行预测，如图所示：</p><p><img loading="lazy" src="/assets/images/84-51b8be27f050575c4661b9ec0bbe701d.png" width="1082" height="342" class="img_ev3q"></p><p>上图所示的方法已经在分支指令的方向预测中出现过，只是现在将<code>PHT</code>换成了<code>Target Cache</code>。</p><p>一种完整的分支预测方法如图所示：</p><p><img loading="lazy" src="/assets/images/85-22660639971ea8c93fc6c0d2ce084ec1.png" width="802" height="728" class="img_ev3q"></p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="分支预测失败时的恢复">分支预测失败时的恢复<a class="hash-link" href="#分支预测失败时的恢复" title="Direct link to heading">​</a></h2><p>分支预测是一种预测技术，需要处理器中有对应的验证和恢复机制，在流水线的很多阶段都可以对分支预测是否正确进行检查，它们包括以下几点。</p><ol><li>在解码阶段，可以得到一个<code>PC</code>值对应的指令是否是分支指令，以及这条分支指令的类型，如果这条指令是直接跳转类型的分支指令，还可以在这个阶段得到它的目标地址，因此在解码阶段可以对一部分的分支指令是否预测正确进行检查。如果此时发现了分支预测失败，可以马上进行恢复，但如果此时仍不能获得处理取指令的正确地址，则可以简单地停止流水线。</li><li>在读取物理寄存器的阶段，如果此时读取到了寄存器的值，那么就可以对间接跳转类型的分支指令所预测的目标地址进行检查，如果发现目标地址预测错误了，那么就可以使用正确的地址开始重新取指令，此时可能需要在发射队列中选择性的清除指令。</li><li>在执行阶段，不管什么类型的分支指令都可以被计算出结果，此时可以对分支预测是否正确进行检查。对于乱序执行的超标量处理器，此时的流水线中还有部分指令是在这条分支指令之前进入流水线中的，它们不应该受到分支预测失败的影响，可以继续执行，而<code>ROB</code>中记录了指令之间本来的顺序，因此可以使用<code>ROB</code>对分支预测失败时的处理器进行状态恢复。除了采用基于<code>ROB</code>的方法进行分支预测失败时的状态恢复，很多现代的处理器都采用了基于<code>Checkpoint</code>的方法进行状态恢复。所谓<code>Checkpoint</code>，是指发现分支指令，并且在分支指令之后的指令更改处理器的状态之前，将处理器的状态保存起来，这里所要保存的处理器状态主要是指寄存器重命名中使用的映射表<code>mapping table</code>，还有预测跳转的分支指令对应的下一条指令的<code>PC</code>值等。为了选择性的清除指令，可以对每一条分支指令进行编号，所有在这条分支指令后面进入到流水线的指令都会得到这个编号，直到遇到下一条分支指令为止。分支指令的编号个数决定了最多可以在流水线中存在的分支指令个数，这个编号值都会保存在一个<code>FIFO</code>中，这个<code>FIFO</code>称为编号列表<code>tag list</code>，它的容量等于处理器最多支持的分支指令的个数。一旦这个列表满了，就不能再向流水线中送入分支指令。因此，如果再解码出分支指令，就会暂停解码阶段之前的流水线，直到编号列表中有空余的空间为止。可以通过<code>tag list</code>和<code>free tag list</code>分别记录已使用和未使用的编号值，工作流程如下：</li></ol><p><img loading="lazy" src="/assets/images/86-4dcc9668efd86a56373830787041dce1.png" width="1080" height="656" class="img_ev3q"></p><p>需要注意的是，编号值的分配应该放置于解码阶段。</p><p>通过编号列表的编号值来找到处于分支预测失败路径上指令的流程如图所示：</p><p><img loading="lazy" src="/assets/images/87-c53aa567f83574d2345c16df6920c28a.png" width="1256" height="524" class="img_ev3q"></p><p>其实，并不是一定需要在一个周期之内将<code>ROB</code>和<code>Issue Queue</code>中的相关指令都清楚掉，因为在流水线的执行阶段发现一条分支指令预测错误时，需要从正确的地址开始取指令，这些新取出来的指令需要经过流水线的好几个阶段才可以到达发射阶段，只要在新指令到达这个阶段之前，<code>ROB</code>和<code>Issue Queue</code>以及发射阶段之后的其他流水级中的相关指令被清楚，那么流水线就可以使用到正确的状态，不需要暂停了，因此可以每周期只从分支指令的<code>tag list</code>广播一个或几个编号值。</p><p>在每周期执行多条指令的超标量处理器中，为了避免使用多端口的<code>FIFO</code>，可以约定在流水线的解码阶段每周期最多只能处理一条分支指令。如果在解码阶段，发现从<code>IB</code>中读出的N条指令中存在多于一条的分支指令，那么第二条分支指令及其后面的所有指令在本周期就不能够进入解码阶段，它们会被延迟到下一个周期。</p><p>要想在流水线的后续阶段得到分支指令的预测值，就需要在流水线的解码阶段，将每条指令的预测值保存起来，比如使用缓存来保存那些预测跳转的分支指令：</p><p><img loading="lazy" src="/assets/images/88-e61aded81a77c5811ad9a420fb2186cd.png" width="1222" height="458" class="img_ev3q"></p><p>一条分支指令如果被预测发生跳转，那么会将它的信息写到<code>PTAB</code>中，同时这条分支指令在<code>PTAB</code>中的地址也随着分支指令在流水线中流动，这样，当这条分支指令到达流水线的执行阶段时，就可以使用这个地址，直接从<code>PTAB</code>中找到对应的预测信息了。</p><p><code>PTAB</code>只需要保存所有预测预测跳转的分支指令，这样可以减少<code>PTAB</code>的容量，在这种情况下，写<code>PTAB</code>的过程可以在流水线的取指令阶段完成，只要在取指令阶段预测到一条发生跳转的分支指令，就将其写到<code>PTAB</code>中。对于<code>自修改代码</code>，执行完成后，需要将<code>分支预测器</code>、<code>I-Cache</code>等部件中的内容都进行清空，这样才能够保证流水线可以正确地执行被修改过的指令。</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="超标量处理器的分支预测">超标量处理器的分支预测<a class="hash-link" href="#超标量处理器的分支预测" title="Direct link to heading">​</a></h2><p>如果对超标量处理器取指令的过程进行限制，例如对于一个<code>4-way</code>的超标量处理器来说，使每周期取出的指令位于四字对齐的边界之内，那么这样就可以使用它们的公共地址来寻址分支预测器，而对于分支预测器来说，它只需要记录下每组四字对齐的指令中，第一个预测跳转的分支指令的信息就可以了。需要注意的是，在<code>BTB</code>中需要记录下分支指令在四条指令中的位置，避免有些时候错误地使用它的结果，如图所示：</p><p><img loading="lazy" src="/assets/images/89-0c1fdaa87a0cdd7e29fba25493bbc79c.png" width="638" height="280" class="img_ev3q"></p><p>对于一个<code>4-way</code>的超标量处理器来说，每周期取出的指令可以不局限于四字对齐的边界之内，那么要达到最理想的效果，就需要对一个周期内取出的所有指令都进行分支预测，将第一个预测跳转的分支指令的目标地址作为下个周期取指令的地址，如图所示：</p><p><img loading="lazy" src="/assets/images/90-62e7860145992f4433c8fa6e3f930018.png" width="1316" height="790" class="img_ev3q"></p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="交叠方式">交叠方式<a class="hash-link" href="#交叠方式" title="Direct link to heading">​</a></h3><p>交叠方式是在超标量处理器中经常使用的一种结构，可以通过单端口存储器来模拟多端口的结构，例如对于<code>PHT</code>，可以采用如图的方式实现四个读端口：</p><p><img loading="lazy" src="/assets/images/91-0fab9004066e5556d5388e8cec3d7854.png" width="1334" height="638" class="img_ev3q"></p><p>在超标量处理器内部，这种<code>交叠</code>结构的存储器是经常被使用的，大部分多端口的功能部件都需要使用这种结构，例如<code>ROB</code>、<code>Issue Queue</code>和<code>Instruction Buffer</code>等部件。</p></div><footer class="theme-doc-footer docusaurus-mt-lg"><div class="theme-doc-footer-edit-meta-row row"><div class="col"><a href="https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/superscalar-processor-architecture/branch-prediction.md" target="_blank" rel="noreferrer noopener" class="theme-edit-this-page"><svg fill="currentColor" height="20" width="20" viewBox="0 0 40 40" class="iconEdit_Z9Sw" aria-hidden="true"><g><path d="m34.5 11.7l-3 3.1-6.3-6.3 3.1-3q0.5-0.5 1.2-0.5t1.1 0.5l3.9 3.9q0.5 0.4 0.5 1.1t-0.5 1.2z m-29.5 17.1l18.4-18.5 6.3 6.3-18.4 18.4h-6.3v-6.2z"></path></g></svg>Edit this page</a></div><div class="col lastUpdated_vwxv"></div></div></footer></article><nav class="pagination-nav docusaurus-mt-lg" aria-label="Docs pages navigation"><a class="pagination-nav__link pagination-nav__link--prev" href="/docs/superscalar-processor-architecture/virtual-memory"><div class="pagination-nav__sublabel">Previous</div><div class="pagination-nav__label">虚拟存储器</div></a><a class="pagination-nav__link pagination-nav__link--next" href="/docs/superscalar-processor-architecture/isa"><div class="pagination-nav__sublabel">Next</div><div class="pagination-nav__label">指令集体系</div></a></nav></div></div><div class="col col--3"><div class="tableOfContents_bqdL thin-scrollbar theme-doc-toc-desktop"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#分支指令的方向预测" class="table-of-contents__link toc-highlight">分支指令的方向预测</a><ul><li><a href="#根据最后一次结果进行预测" class="table-of-contents__link toc-highlight">根据最后一次结果进行预测</a></li><li><a href="#基于两位饱和计数器的分支预测" class="table-of-contents__link toc-highlight">基于两位饱和计数器的分支预测</a></li><li><a href="#基于局部历史的分支预测" class="table-of-contents__link toc-highlight">基于局部历史的分支预测</a></li><li><a href="#基于全局历史的分支预测" class="table-of-contents__link toc-highlight">基于全局历史的分支预测</a></li><li><a href="#竞争的分支预测" class="table-of-contents__link toc-highlight">竞争的分支预测</a></li><li><a href="#分支预测的更新" class="table-of-contents__link toc-highlight">分支预测的更新</a></li></ul></li><li><a href="#分支指令的目标预测" class="table-of-contents__link toc-highlight">分支指令的目标预测</a><ul><li><a href="#直接跳转类型的分支预测" class="table-of-contents__link toc-highlight">直接跳转类型的分支预测</a></li><li><a href="#间接跳转类型的分支预测" class="table-of-contents__link toc-highlight">间接跳转类型的分支预测</a></li></ul></li><li><a href="#分支预测失败时的恢复" class="table-of-contents__link toc-highlight">分支预测失败时的恢复</a></li><li><a href="#超标量处理器的分支预测" class="table-of-contents__link toc-highlight">超标量处理器的分支预测</a><ul><li><a href="#交叠方式" class="table-of-contents__link toc-highlight">交叠方式</a></li></ul></li></ul></div></div></div></div></main></div></div><footer class="footer footer--dark"><div class="container container-fluid"><div class="row footer__links"><div class="col footer__col"><div class="footer__title">Docs</div><ul class="footer__items clean-list"><li class="footer__item"><a class="footer__link-item" href="/docs/intro">Tutorial</a></li></ul></div><div class="col footer__col"><div class="footer__title">Community</div><ul class="footer__items clean-list"><li class="footer__item"><a href="https://stackoverflow.com/questions/tagged/docusaurus" target="_blank" rel="noopener noreferrer" class="footer__link-item">Stack Overflow<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li><li class="footer__item"><a href="https://discordapp.com/invite/docusaurus" target="_blank" rel="noopener noreferrer" class="footer__link-item">Discord<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li><li class="footer__item"><a href="https://twitter.com/docusaurus" target="_blank" rel="noopener noreferrer" class="footer__link-item">Twitter<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li></ul></div><div class="col footer__col"><div class="footer__title">More</div><ul class="footer__items clean-list"><li class="footer__item"><a class="footer__link-item" href="/blog">Blog</a></li><li class="footer__item"><a href="https://github.com/facebook/docusaurus" target="_blank" rel="noopener noreferrer" class="footer__link-item">GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li></ul></div></div><div class="footer__bottom text--center"><div class="footer__copyright">Copyright © 2023 yufoo1's Site.</div></div></div></footer></div>
<script src="/assets/js/runtime~main.9657dcaa.js"></script>
<script src="/assets/js/main.b62e56eb.js"></script>
</body>
</html>