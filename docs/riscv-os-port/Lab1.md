---
sidebar_position: 2
---
# Lab 1：内核启动和 Printf 的实现

## 内核启动

笔者建议在最开始仅添加`内核启动`的必要代码，而不要直接编译全部代码，随着移植的进行再往其中添加其他内容，并进行部分的`修改`与`扩充`，但涉及 `32` 位与 `64` 位差异的地方基本都需要重构，后文会详细介绍。

就内核启动而言，我们需要 `start.S`、内核的链接脚本、`Makefile` 相关的文件、头文件，特别地，对于 `RISC-V` 架构而言，启动还需要 `opensbi`。

这里简单介绍下 `opensbi` 的作用，对于 `RISC-V` 架构的处理器而言，一般指令可以运行在三种模式下：机器模式 `machine mode`（`M态`）、监管者模式 `supervisor mode`（`S态`）、用户模式`user mode`（`U态`）。其中，前两种模式都比用户模式有着更高的权限，具有处理中断和执行 `I/O` 的功能，而大部分时间下，在执行用户程序时处理器处于用户模式。在 `MOS` 中，我们可以理解成只有内核态和用户态两种模式，处理用户程序就在用户态，处理中断异常就在内核态，而我们在对内核进行初始化，开启内存管理、进程管理等功能时，是处于内核态的。类比来说，`RISC-V` 架构中的 `supervisor mode` 就是 `MOS` 中的内核态，也是我们作为操作系统撰写者可以接触的模式。`opensbi` 是处于 `machine mode` 的代码，也就是说，`opensbi` 对内存、`I/O`以及一些用于启动和配置系统的底层功能来说有着完全的使用权。它除了具有引导内核启动的功能，还具有异常分发的功能，比如我们在用户态发生异常时，会从 `U态`陷入 `M态`，`M态` 可以决定是在 `M态` 处理异常，还是把异常下放到 `S态` 来交给我们处理。

在 `qemu` 中，`opensbi` 默认被链接到的地址空间是 `0x80000000`，因此我们需要将这段空间预留出来。

> 如果希望自己编译`opensbi`，可以在[opensbi][https://github.com/riscv-software-src/opensbi]处自行下载源码，设置好工具链的路径即可进行编译，使用`make PLATFORM=generic`。然后 `qemu` 启动内核时，设置 `-bios $(OPENSBI)` 参数，其中 `OPENSBI` 代表 `opensbi` 源码编译得到的 `build/platform/generic/firmware`目录下的 `fw_dynamic.bin` 的路径，可以自己设置。
>
> 高版本的 `qemu` 内置了 `opensbi` ，比如笔者使用的`6.2.0_1`，在启动时不需要添加 `-bios` 参数。但如果读者希望追踪 `opensbi` 中代码运行的过程，建议还是自行编译 `opensbi`。

### 链接脚本

链接脚本需要注意或者可以优化的点有：

* 注意设置`ENTRY(_start)`，使内核启动时跳转至该地址。
* 为`opensbi` 预留出 `0x80000000~0x80200000` 的地址空间，即我们在链接脚本中不要将内容放置在该区域。同时，无论是使用自行编译的 `opensbi`，还是使用 `qemu` 内置的 `opensbi`， `qemu` 都会自动帮我们将 `opensbi` 链接至上述预留地址，不需要我们操心。
* 每个 `segment` 在填入后可以紧跟一条`. = ALIGN(4096);`来将页面对齐，笔者认为可以减少出锅的风险。
* 记录几个比较关键的 `segment` 的起点和终点，还有就是内核代码链接的起点和终点，便于后续初始化内存管理时使用，笔者选择内核代码链接至 `0x80200000~0x80400000`地址空间，`0x80000000~0x80200000` 留给`opensbi`。

### start.S

在 `MOS` 中，该文件需要：

* 定义内核的栈空间，并全局化
* 定义异常分发函数
* 设置 `CP0` 寄存器，并跳转至 `main.c` 文件中的 `main` 函数

在我们移植的内核当中，同样需要完成这些事情，可以模仿 `MOS` 完成，但笔者想起了 `MOS` 当中一些看似严谨但实则没必要的操作，比如为内核启动单独配备一套函数，其实完全没必要；还有就是我们已经在`start.S`中定义了内核栈空间，不如一起将内核页目录一同定义在该处，然后删去曾经那套为内核启动配备的函数，简化了内核。

还有就是，再和助教学长的交流当中，我们一致认为 `MOS` 将很多中断异常的处理交给汇编代码的实现虽然也能保证正确，但是难以调试、容易出错，联系到有一次 `OS` 上机，身边同学通过 `C语言` 迅速通过课上测试的事迹，笔者决意将原来 `MOS` 处理中断异常的代码全部交给高级语言处理，包括设置特权寄存器的操作，这样对于笔者来说更容易调试，看起来实现也更优美。

因此，笔者的 `FibOS` 中，该文件仅需要：

* 定义内核的栈空间，全局化
* 定义内核的页目录，全局化
* 直接跳转到 `init.c` 文件中的 `main` 函数（删除了 `main.c` 这个无用中转站）

另外，对于原先 `MOS` 中定义的 `LEAF`、`NESTED` 等宏，笔者认为可以直接舍弃，因为 `MOS` 中那些伪指令大多在 `RISC-V` 中不能使用，因此笔者自己定义了一个很简单的宏，只实现了将汇编函数全局化的功能：

```assembly
#define FUNC(symbol)    \
    .globl      symbol; \
    .align	    12;     \
    symbol:
```

### Makefile

`Makefile` 的编写相当灵活，相比原来，其实也不需要修改什么，只需要按照个性的需求简单调整，这里就不再赘述了，关键的一步是把 `RISC-V` 工具链的路径在 `include.mk` 中设置好。

## printf 与 UART

原来 `MOS` 中 `printf` 最终是通过将字符输出到这个外设地址实现的：

```c
void printcharc(char ch)
{
	*((volatile unsigned char *) PUTCHAR_ADDRESS) = ch;
}
```

在 `RISC-V` 中，我们可以通过两种方式实现字符的打印，一个是通过 `sbi call` 调用 `ecall` 借助 `M级` 实现，但是据助教学长说，这个方式在 `Lab 6` 会出锅，原因是 `opensbi` 的源码在读取字符的时候并没有轮训，读不到就返回，也就是说如何我们希望读取字符，很可能等待不到键盘输入就提前返回了。

> 这里祝陈学长的 `issue` 早日被 `opensbi` 开发者采纳。

笔者最初是通过 `sbi call` 实现的字符打印，~~因为这样非常简单，只要把 `myoutput` 中打印字符的函数改成 `sbi call` 就行~~，但考虑到之后想完成 `Lab 6`（其实最终并未完成，卡在了 `lab5`），还是选择了学长推荐的 `UART ` 实现方式，对于打印一个字符可以通过如下代码实现：

```c
inline void putchar(char ch)
{
    int* uartRegTXFIFO = (int*)(uartBase + UART_REG_TXFIFO); // 设置 UART 写入地址
		while (readl(uartRegTXFIFO) & UART_TXFIFO_FULL); // 如果该地址有数据且还没读取，则轮训等待
    writel(ch, uartRegTXFIFO); // 该地址没有数据时，可以写入
}
```

而我们对该函数的调用，无论是`S态`还是`U态`，都可以通过系统调用统一实现，~~因此本人直到 `Lab 4` 才将 `sbi call` 的写法改正过来~~。采用 `UART` 的写法还有一点需要注意，就是它设计到了 `MMIO` 的知识，我们需要参考开发版手册 [SiFive FU540-C000 Manual v1p4][https://sifive.cdn.prismic.io/sifive/d3ed5cd0-6e74-46b2-a12d-72b06706513e_fu540-c000-manual-v1p4.pdf] 事先对 `UART` 的地址空间进行映射（后面还要对其他 `MMIO` 的地址进行映射），这样才能够调用 `printf` ，关于地址映射，笔者会在 `Lab 2` 详细介绍。
