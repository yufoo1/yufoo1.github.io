---
sidebar_position: 4
---
# Lab 3：异常处理和进程管理

## 时钟中断

接下来需要开启时钟中断，来告知处理器进行进程调度，从 `S态` 切换至 `U态`。不过现在我们是没有用户程序的，因此如何测试正常响应了时钟中断呢？在 `RISC-V` 架构的处理器中，如果调用 `ecall` ，会自动跳转至当前 `stvec` 寄存器中存储的地址，这与 `MOS` 类似，不过 `MOS` 是将异常分发函数放置于 `start.S` 文件，我由于之前提到的原因，通过高级语言对异常分发函数进行了重写。但完全避免汇编是没必要的，再进行上下文存储这种简单的操作时，可以通过汇编直接实现，比如我们在 `trap init` 的第一步，设置 `stval` 为一个上下文保存函数，也就是 `MOS` 中的 `env_pop_tf`，汇编的部分都是需要重写的，如果沿用 `MOS` 的写法会有很大调试难度，因此我这里只将这个函数的功能弱化为将 `32` 个寄存器压入内核栈中，然后跳转至异常分发函数，这是一个由`C语言`重写的函数，对应 `MOS` 中的 `except_vec3`。然后只需要在异常分发函数处调用 `ecall`随便打印一个字符，就可以判断处理器是否成功相应了中断。

那么处理器如何采用相应时钟中断，这部分内容涉及 `RISC-V` 架构的特权寄存器，笔者查阅了手册，认为需要开启 `sie` 寄存器的 `SSIE` 位和 `USIE` 位；同时开启 `sstatus` 寄存器的 `SIE` 和 `UIE` 位。开启这些后，处理器就肯定可以响应时钟中断了。

> 学长是说要开启 `sie` 的 `SEIE` 、`SSIE` 、`STIE` 以及 `sstatus` 的 `SIE` 。

处理器可以响应了，那时钟信号从哪里来呢？我们可以通过 `sbi call` 设置时钟，比如 `sbi_set_timer(r_time() + INTERVAL);`，其中 `r_time()` 代表读取当前处理器 `TIME` 寄存器中的数据，表示当前时刻的时间，而 `INTERVAL` 代表我们希望在 `INTERVAL` 长的时间间隔后发生一次时钟中断。可以看出，这行代码只能实现一次时钟中断，如果希望实现定时的时钟中断，需要在我们响应时钟中断的时候，再次调用 `sbi_set_timer` 这个函数。

## 进程管理

进程管理的初始化几乎不需要修改代码，唯一特殊的一点是，对于 `RISC-V` 架构的处理器，`sscratch` 这个寄存器保存的是当前进程 `trapframe` 的虚拟地址，而 `trapframe` 中保存着当前进程的上下文信息，包括所有普通寄存器，以及 `sepc`、`satp`、这类特殊的寄存器，因此我们需要为每一个进程都分配一个 `trapframe` 大小的内存空间，并且互相地址不冲突，前文提到过，这是从 `MOS` 的进程控制块数组中提取出来的一部分，因此对所有进程可见。移植进展到这个阶段的时候，笔者曾和学长们讨论过许久 `MOS` 中为什么要区分内核栈和时钟栈，大部分学长认为这个时钟栈设计是可以舍弃的，当时是 `MOS` 的一个阑尾，因此笔者就将时钟栈 `TIMESTACK` 舍弃了，前面提到过，发生中断异常陷入 `S态` 时，会将当前进程的上下文保存到内核栈里面，因此我们在从 `S态` 返回 `U态`的时候，会从内核栈中将上下文恢复至 `trapframe`。

## 用户程序

加载用户程序的过程会很玄学，加载用户程序部分的代码需要调整，并且 `32` 位和 `64` 位的 `ELF` 文件头结构体定义有差异，很坑，可以参考这篇文章[ELF][https://en.wikipedia.org/wiki/Executable_and_Linkable_Format]，其他改动不大。

## 异常处理

在 `FibOS` 中，`S态` 发生中断和 `U` 态发生中断会进入到不同的中断处理程序中，具体进入到哪个看目前 `stvec` 中记录的值。在内核初始化阶段， `stvec` 被设置为内核中断处理程序的入口，而当调度并运行用户程序时，会将目前 `stvec` 修改为用户中断处理程序的入口。

在 `RISC-V` 中，发生 `TLB` 时 `MMU` 时自动回填，因此不需要我们操心 `TLB`，主要需要关心的是处理时钟中断以及系统调用，其他时钟中断我们基本处理完成了，系统调用和 `MOS` 中流程一致，但是笔者对于 `MOS` 处理系统调用的流程重新整理了下，修改部分函数名，更为清晰。举个例子来说，对于用户程序而言，系统调用的过程是透明的，我们不该刻意地起个以 `syscall` 为前缀的用户函数来证明我们需要使用系统调用，因此我把所有的函数修改地更为`用户化`了。另外，在 `MOS` 中系统调用的汇编指令是 `syscall`，在 `RISC-V` 中是 `ecall`，需要通过如下方式实现：

```c
inline u64 inline msyscall(long n, u64 _a0, u64 _a1, u64 _a2, u64
		_a3, u64 _a4, u64 _a5) {
	register u64 a0 asm("a0") = _a0;
	register u64 a1 asm("a1") = _a1;
	register u64 a2 asm("a2") = _a2;
	register u64 a3 asm("a3") = _a3;
	register u64 a4 asm("a4") = _a4;
	register u64 a5 asm("a5") = _a5;
	register long syscall_id asm("a7") = n;
	asm volatile ("ecall" : "+r"(a0) : "r"(a1), "r"(a2), "r"(a3), "r"(a4), "r"
			(a5), "r"(syscall_id));
	return a0;
}
```

然后过程就和处理时钟中断时基本一致，不同的是，在进行系统调用时，异常分发函数应该使处理器跳转到对应的 `handler`，这点与 `MOS` 一致。
