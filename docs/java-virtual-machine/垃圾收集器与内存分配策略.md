---
sidebar_position: 2
---
# 垃圾收集器与内存分配策略

## 对象已死？

### 可达性分析算法

该算法的基本思路就是通过一系列称为`GC Roots`的根对象作为起始节点集，从这些节点开始，根据引用关系向下搜索，搜索过程所走过的路径称为`引用链`，如果某个对象到`GC Roots`间没有任何引用链相连，则证明此对象是不可能再被使用的。

在`Java`技术体系里面，固定可作为`GC Roots`的对象包括以下几种：

1. 在`虚拟机栈`的`本地变量表`中引用的对象：譬如当前正在运行的方法所使用到的参数、局部变量、临时变量等。

2. 在方法区中`常量引用的对象`：譬如字符串常量池里的引用。
3. 在`本地方法栈`中`JNI`引用的对象。
4. `Java`虚拟机内部的引用：如基本数据类型对应的`Class`对象，一些常驻的异常对象，还有系统类加载器。
5. 所有被同步锁（`synchronized`关键字）持有的对象。
6. 反应`Java`虚拟机内部情况的`JMXBean`、`JVMTI`中注册的回调、本地代码缓存等。

### 再谈引用

`Java`对引用的概念进行了扩充，将引用分为`强引用`、`软引用`、`弱引用`和`虚引用`，这四种引用强度依次逐渐减弱。

1. 强引用：`Object obj = new Object()`，无论任何情况下，只要强引用关系还存在，垃圾收集器就永远不会回收掉被引用的对象。
2. 软引用：有用，但非必须的对象。被软引用关联的对象，在系统将要发生内存溢出异常前，会把这些对象列进回收范围之中进行第二次回收，如果这次回收还没有足够的内存，才会抛出内存溢出异常。
3. 弱引用：非必须对象，被弱引用关联的对象只能生存到下一次垃圾收集发生为止。
4. 虚引用：为一个对象设置虚引用关联的唯一目的只是为了能在这个对象被收集器回收时收到一个系统通知。

### 生存还是死亡？

要真正宣告一个对象死亡，最多会经历两次标记过程：如果对象在进行可达性分析后发现没有与`GC Roots`相连接的引用链，那它将会被第一次标记，随后进行一次筛选，筛选的条件时此对象是否有必要执行`finalize()`方法。假如对象没有通过`Override`覆盖`finalize()`方法，或者`finalize()`方法已经被虚拟机调用过，那么虚拟机将这两种情况都视为`没有必要执行`。

如果这个对象被判定为确有必要执行`finalize()`方法，那么该对象将会被放置在一个`F-Queue`的队列之中，并在稍后由一条虚拟机自动建立的、低调度优先级的`Finalizer`线程去执行它们的`finalize()`方法。如果对象要在`finalize()`中成功拯救自己——只要重新与引用链上的任何一个对象建立关联即可。

然而，`finalize()`如今已被官方明确声明为不推荐使用的语法，其能做的所有工作，使用`try-finally`或者其他方式都可以做得更好、更及时。

## 垃圾收集算法

### 分代收集理论

分代收集理论建立在三个分代假说之上：

1. 弱分代假说：绝大多数对象都是朝生夕灭的。
2. 强分代假说：熬过越多次垃圾收集过程的对象就越难以消亡。
3. 跨代引用假说：跨代引用相对于同代引用来说仅占极少数。

收集器将`Java`堆划分出不同的区域，然后将回收对象依据其`年龄`分配到不同的区域之中存储。在`Java`堆划分出不同的区域之后，垃圾收集器才可以每次只回收其中某一个或者某些部分的区域，因而才有了`Minor GC`、`Major GC`和`Full GC`这样的回收类型划分；也出现了针对不同区域安排与里面存储对象存亡特征相匹配的垃圾收集算法`标记-复制算法`、`标记-清除算法`、和`标记-整理算法`等。

依据第三条假说，我们不需要为了少量的`跨代引用`去扫描整个老年代，也不必浪费空间专门记录每一个对象是否存在及存在哪些跨代引用，只需在`新生代`上建立一个全局的数据结构`Remembered Set`，这个结构把`老年代`划分成若干小块，标识出老年代的哪一块内存会存在跨代引用。此后发生`Minor GC`时，只有包含了跨代引用的小块内存里的对象才会被加入到`GC Roots`进行扫描。

### 标记—清除算法

首先标记出所有需要回收的对象，在标记完成后，统一回收掉所有被标记的对象，也可以反过来，标记存活的对象，统一回收所有未被标记的对象。

它的主要缺点有两个：第一个是执行效率不稳定，如果`Java`堆中包含大量对象，而且其中大部分都需要被回收；第二个是内存的碎片化问题。

### 标记—复制算法

该算法将内存按容量划分为大小相等的两块，每次只使用其中的一块。当一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。

它的主要缺点是空间浪费过大，不过现在的商用`Java`虚拟机大多都优先采用了这种收集算法去回收新生代。`HotSpot`虚拟机的`Serial`、`ParNew`等新生代收集器均采用了`Appel式回收`。它将`新生代区域`分为一块较大的`Eden`空间和两块较小的`Survivor`空间，每次分配内存只使用`Eden`和其中一块`Survivor`。发生垃圾收集时，将`Eden`和`Survivor`中仍然存活的对象一次性复制到另外一块`Survivor`空间上，然后直接清理掉`Eden`和已用过的那块`Survivor`空间。当`Survivor`空间不足以容纳一次`Minor GC`之后存活的对象时，就需要依赖其他内存区域，比如`老年代`，进行分配担保`Handle Promotion`。

### 标记—整理算法

该算法主要针对`老年代`对象的存亡特征，其中的标记过程仍然与`标记——清除`算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向内存空间一端移动，然后直接清理掉边界以外的内存。

