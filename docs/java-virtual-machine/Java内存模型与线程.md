---
sidebar_position: 3
---
# Java内存模型与线程

## 概述

内存模型可以理解为在特定的操作协议下，对特定的内存或高速缓存进行读写访问的过程抽象。不同架构的物理机器可以拥有不一样的内存模型，而`Java`虚拟机也有自己的内存模型，并且与内存访问操作及硬件的缓存访问操作具有高度的可类比性。除了增加高速缓存之外，为了使处理器内部的运算单元能尽可能被充分利用，处理器可能会对输入代码进行乱序执行优化，而`Java`虚拟机的即时编译器中也有指令重排序优化。

## Java 内存模型

《Java虚拟机规定》中曾试图定义一种`Java内存模型`来屏蔽各种硬件和操作系统的内存访问差异，以实现让`Java`程序在各种平台下都能达到一致的内存访问效果。在此之前，主流程序语言，如`C`和`c++`，直接使用物理硬件和操作系统的内存模型。由于不同平台上内存模型的差异，有可能导致程序在一套平台上并发完全正常，而在另外一套平台上并发访问却经常出错。

### 主内存与工作内存

`Java内存模型`的主要目的是定义程序中各种变量的访问规则，即关注在虚拟机中把变量值存储到内存和从内存中取出变量值这样的底层细节。此处提到的`变量`包括了实例字段、静态字段和构成数组对象的元素，不包括局部变量与方法参数，因为后者是线程私有的，不存在竞争问题。

`Java内存模型`规定了所有的变量都存储在`主内存`中，物理上，`主内存`仅是虚拟机内存的一部分。每条线程还有自己的`工作内存`，线程的工作内存中保存了被该线程使用的变量的`主内存副本`，线程对变量的所有操作都必须在工作内存中进行，而不能直接读写主内存中的数据，线程间变量值的传递需要通过主内存来完成。

### 内存间交互操作

关于主内存与工作内存之间具体的交互协议，`Java内存模型`中定义了`8种`操作来完成，`Java`虚拟机实现时必须保证下面提及的每一种操作都是原子的。

1. `lock`：作用于主内存的变量，它把一个变量标识为一条线程独占的状态。
2. `unlock`：作用于主内存的变量，它把处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定。
3. `read`：作用于主内存的变量，它把一个变量的值从主内存传输到线程的工作内存中，以便随后的`load`动作使用。
4. `load`：作用于工作内存的变量：它把`read`操作从主内存中得到的变量值放入工作内存的变量副本中。
5. `use`：作用于工作内存的变量，它把工作内存中一个变量的值传递给执行引擎，每当虚拟机遇到一个需要使用变量的值的字节码指令时将会执行这个操作。
6. `assign`：作用于工作内存的变量，它把一个从执行引擎接收的值赋给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作。
7. `store`：作用于工作内存的变量，它把工作内存中一个变量的值传送到主内存中，以便随后的`write`操作使用。
8. `write`：作用于主内存的变量，它把`store`操作从工作内存中得到的变量的值放入主内存的变量中。

`Java`内存模型要求在把变量从主内存拷贝到工作内存时，需要按顺序执行`read`和`load`操作；在把变量从工作内存同步回主内存时，需要按顺序执行`store`和`write`操作，需要注意的是，按顺序并不一定是连续。除此之外，`Java内存模型`还规定了在执行上述基本操作时必须满足如下规则：

1. 不允许`read`和`load`、`store`和`write`操作之一单独出现，即不允许一个变量从主内存读取了但工作内存不接受，或者工作内存发起回写了但主内存不接受的情况出现。
2. 不允许一个线程丢弃它最近的`assign`操作，即变量在工作内存中改变了之后必须把该变化同步到主内存。
3. 不允许一个线程无原因地（没有发生过任何`assign`操作）把数据从线程的工作内存同步回主内存中。
4. 一个新的变量只能在主内存中`诞生`，不允许在工作内存中直接使用一个未被初始化（`load`或`assign`）的变量，换句话说就是对一个变量实施`use`和`store`操作之前，必须先执行`assign`和`load`操作。
5. 一个变量在同一个时刻只允许一条线程对其进行`lock`操作，但`lock`操作可以被同一条线程重复执行多次，多次执行`lock`后，只有执行相同次数的`unlock`操作，变量才会被解锁。
6. 如果对一个变量执行`lock`操作，那将会清空工作内存中此变量的值，在执行引擎使用这个变量前，需要重新执行`load`或`assign`操作以初始化变量的值。
7. 如果一个变量事先没有被`lock`操作锁定，那就不允许对它进行`unlock`操作，也不允许去`unlock`一个被其他线程锁定的变量。
8. 对一个变量执行`unlock`操作之前，必须先把此变量同步回主内存中（执行`store`、`write`操作）。

### 对于 volatile 型变量的特殊规则

关键字`volatile`是`Java`虚拟机提供的最轻量级的同步机制，当一个变量被定义成`volatile`之后，它将具备两项特征。

第一项是保证此变量对所有线程的可见性，即指当一条线程修改了这个变量的值，新值对于其他线程来说是可以立即得知的。由于`volatile`变量只能保证可见性，在不符合以下两条规则的运算场景下，我们仍然要通过加锁来保证原子性：

1. 运算结果并不依赖变量的当前值，或者能够确保只有单一的线程修改变量的值。
2. 变量不需要与其他的状态变量共同参与不变约束。

使用`volatile`变量的第二个语义是`禁止指令重排序优化`。

### 原子性、可见性与有序性

`Java内存模型`是围绕在并发过程中如何处理原子性、可见性和有序性这三个特征来建立的。

1. 原子性：由`Java`内存模型来直接保证的原子性变量操作。
2. 可见性：`Java内存模型`是通过在变量修改后将新值同步回主内存，在变量读取前从主内存刷新变量值这种依赖主内存作为传递媒介的方式来实现可见性的。
3. 有序性：如果在本线程内观察，所有的操作都是有序的；如果在一个线程中观察另一个线程，所有的操作都是无序的。

